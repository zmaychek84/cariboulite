{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "be6b2f35-69ca-3f49-afe0-e7fd1fe6f12f",
              "name": "resources.rules.python.arbitrary-sleep",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.arbitrary-sleep"
              },
              "fullDescription": {
                "text": "time.sleep() call; did you mean to leave this in?"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "time.sleep() call; did you mean to leave this in?\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "time.sleep() call; did you mean to leave this in?\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "24724d34-6f22-307d-b193-2d2a74626e13",
              "name": "resources.rules.python.arbitrary-sleep",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.arbitrary-sleep"
              },
              "fullDescription": {
                "text": "time.sleep() call; did you mean to leave this in?"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "time.sleep() call; did you mean to leave this in?\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "time.sleep() call; did you mean to leave this in?\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "ac2ed76d-d3ed-3603-920d-eddc9c82ae48",
              "name": "resources.rules.python.dlint-catastrophic-redos",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.dlint-catastrophic-redos"
              },
              "fullDescription": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/](https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/)\n - [https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/](https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/)\n"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "b9c142a0-59e6-3fc5-8591-ef43cf911bef",
              "name": "resources.rules.python.arbitrary-sleep",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.arbitrary-sleep"
              },
              "fullDescription": {
                "text": "time.sleep() call; did you mean to leave this in?"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "time.sleep() call; did you mean to leave this in?\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "time.sleep() call; did you mean to leave this in?\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "df4960bd-11d2-35c7-8600-d9136ef76147",
              "name": "resources.rules.python.dlint-catastrophic-redos",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.dlint-catastrophic-redos"
              },
              "fullDescription": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/](https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/)\n - [https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/](https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/)\n"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "0f0db57a-28a9-3ff3-a514-977b00727cd9",
              "name": "resources.rules.python.dlint-catastrophic-redos",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.dlint-catastrophic-redos"
              },
              "fullDescription": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/](https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/)\n - [https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/](https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/)\n"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "65369937-efb7-34e6-8a5a-eb20ac25cc8f",
              "name": "resources.rules.python.arbitrary-sleep",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.arbitrary-sleep"
              },
              "fullDescription": {
                "text": "time.sleep() call; did you mean to leave this in?"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "time.sleep() call; did you mean to leave this in?\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "time.sleep() call; did you mean to leave this in?\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "d543ac71-bf3f-3a7a-a3bd-b4c2610b5860",
              "name": "resources.rules.python.dlint-catastrophic-redos",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.dlint-catastrophic-redos"
              },
              "fullDescription": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Regex `$X` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/](https://r2c.dev/blog/2020/finding-python-redos-bugs-at-scale-using-dlint-and-r2c/)\n - [https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/](https://r2c.dev/blog/2020/improving-redos-detection-with-dlint-and-r2c/)\n"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "ac5751c1-904e-3519-86a1-2459014be77c",
              "name": "resources.rules.python.arbitrary-sleep",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.python.arbitrary-sleep"
              },
              "fullDescription": {
                "text": "time.sleep() call; did you mean to leave this in?"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "time.sleep() call; did you mean to leave this in?\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "time.sleep() call; did you mean to leave this in?\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high"
              }
            },
            {
              "id": "a49ceeea-1ca7-3d5b-b986-b15ff75acc25",
              "name": "\"Prohibited C Function Identified\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. In this case, the function `fopen()` is used with the \"w\" mode, which opens a file for writing. If the file already exists, its contents are discarded and the file is treated as a new empty file. This can lead to potential data loss if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen()`. In C++, the safer alternative is to use the file stream classes (`fstream`, `ifstream`, `ofstream`) provided by the Standard Library. These classes provide better control over file operations and are less prone to errors.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `ofstream`:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library that provides facilities for file-based input and output.\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "e7f4cdb0-194b-3405-a75e-2419864dc261",
              "name": "\"Prohibited C Function Identified\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. In this case, the function `fopen()` is used with the \"w\" mode, which opens a file for writing. If the file already exists, its contents are discarded and the file is treated as a new empty file. This can lead to potential data loss if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen()`. In C++, the safer alternative is to use the file stream classes (`fstream`, `ifstream`, `ofstream`) provided by the Standard Library. These classes provide better control over file operations and are less prone to errors.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `ofstream`:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library that provides facilities for file-based input and output.\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "01cee931-d83f-3128-af3f-86e441e854cc",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility of a null pointer being used as the destination in the memory copy operation. The analysis did not detect any explicit checks to ensure that the destination pointer is not null before the memory copy occurs. The source is likely safe, as it is not a pointer expression, but the destination pointer may be null, which could lead to a crash or other unpredictable behavior. The absence of a guard or capacity check further increases the risk. The probability of this being a false positive is very low, as the evidence strongly suggests a real issue.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is null.\n\n```c\nif (msg != NULL) {\n    memcpy(msg, aux, bits/8);\n} else {\n    // Handle error: destination pointer is null\n}\n```\n\nAlternatively, if both source and destination pointers could be null, check both:\n\n```c\nif (msg != NULL && aux != NULL) {\n    memcpy(msg, aux, bits/8);\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\n\n## In Context Remediation 2\nIf the function expects the destination pointer to always be valid, add an assertion to catch programming errors during development:\n\n```c\nassert(msg != NULL);\nmemcpy(msg, aux, bits/8);\n```\n\nThis will terminate the program in debug builds if the pointer is null, helping to catch the issue early.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476"
                ]
              }
            },
            {
              "id": "f7cfbeb6-8f6b-3b9d-bfd1-9c52b4ad1645",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The source buffer (msg) may be null at this location, as there is no explicit check to ensure it is not null before the memory copy operation. The destination buffer is an array, so it cannot be null, but the lack of a null check on the source pointer is a significant risk. There is no evidence of overlapping memory regions, and the copy size is determined by a calculation (msgbits/8) that is not directly tied to the destination's capacity, increasing the risk of misuse. No explicit guard or null-termination is present. These factors all contribute to the assessment that this is a real issue that could lead to a crash or other undefined behavior if the source pointer is null.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source pointer is not null. Add an explicit check to prevent undefined behavior if the source is null.\n\n```c\nif (msg != NULL) {\n    memcpy(aux, msg, msgbits/8);\n} else {\n    // Handle error: source pointer is null\n    // e.g., log an error, return an error code, or take other appropriate action\n}\n```\n\nThis check prevents the function from attempting to copy from a null pointer, which would otherwise result in a crash or undefined behavior.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "0841f7f1-721e-360b-a8fa-ddf46254c05f",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict for this call site is marked as genuine. The source buffer ('msg') may be null at this location, as there is no explicit check to ensure it is not null before the memory copy operation. The destination buffer ('aux') is an array, so it cannot be null, reducing risk on the destination side. There is no evidence of overlapping memory regions, which further reduces the risk of undefined behavior from overlap. However, the absence of a null check for the source pointer is a significant concern, as dereferencing a null pointer will cause a crash or other unpredictable behavior. The probability of this being a false positive is low, as the analysis has identified a real risk based on the lack of null checks and the use of a potentially null source pointer.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the source pointer is not null. Add an explicit check to verify that the source buffer ('msg') is valid. If 'msg' can be null, handle this case appropriately (e.g., return an error, skip the operation, or initialize the destination buffer to a safe value).\n\n```c\nif (msg != NULL) {\n    memcpy(aux, msg, bits/8);\n} else {\n    // Handle error: source buffer is null\n    // For example, zero out aux or return an error code\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476"
                ]
              }
            },
            {
              "id": "11f83fc2-8a94-34ee-88e6-24f5bcbaf35a",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility of null pointers being used as the destination in a memory copy operation. The analysis did not detect any explicit checks to ensure that the destination pointer is not null before the memory copy occurs. The source is an identifier and is not likely to be null, but the destination pointer may be null, which could lead to a crash or other unpredictable behavior. There are no guards or capacity checks present, and the count argument is not directly tied to the size of the destination buffer, increasing the risk. The absence of overlap between source and destination reduces the risk of data corruption, but the null pointer risk remains significant.\n\n## In Context Remediation 1\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is null.\n\n```c\nif (msg != NULL) {\n    memcpy(msg, aux, bits/8);\n} else {\n    // Handle error: destination pointer is null\n}\n```\nThis check prevents the function from attempting to copy memory to a null destination, which would otherwise result in a crash or undefined behavior.\n\n## In Context Remediation 2\nIf both the source and destination pointers could potentially be null, add checks for both before the memory copy operation:\n\n```c\nif (msg != NULL && aux != NULL) {\n    memcpy(msg, aux, bits/8);\n} else {\n    // Handle error: one or both pointers are null\n}\n```\nThis approach ensures that neither pointer is null before proceeding, further reducing the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  },
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476",
                  "CWE-119"
                ]
              }
            },
            {
              "id": "86f2987b-bc22-31e8-9d65-bdebd57877de",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that the destination pointer may be null, and there are no explicit checks to prevent this. The analysis shows that the destination pointer ('info') could be null at the point of the memory copy operation, and there is no guard in place to ensure it is valid. The source pointer is safe, as it is always non-null due to being the address of a structure member. The use of 'memcpy' with a potentially null destination pointer can lead to a crash or other undefined behavior. The probability of this being a false positive is low, as the risk is clearly present and not mitigated by any checks or safe usage patterns.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is invalid.\n\n```c\nif (info != NULL) {\n    memcpy(info, &sys->board_info, sizeof(hat_board_info_st));\n} else {\n    // Handle error: destination pointer is null\n    // For example, log an error or return an error code\n}\n```\n\nThis check ensures that the function does not attempt to write to a null pointer, which would otherwise cause a crash or undefined behavior.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "48dbf12d-eb92-368c-817f-0c0a4b16ae55",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the automated verdict also marks it as genuine. The code copies data from one buffer to another using a memory copy operation, but there is no evidence of checks to ensure that the source pointer is not null. The source buffer is a variable, and the analysis indicates that it may be null at this point in the code. The destination buffer is an array, so it is unlikely to be null. There is no explicit guard or check to prevent copying from a null source, which could lead to a crash or other undefined behavior. The probability of this being a false positive is low because the risk is clearly present and not mitigated by any visible checks.\n\n## In Context Remediation 1\nBefore performing the memory copy operation, ensure that the source pointer is not null. Add an explicit check to prevent undefined behavior if the source is null.\n\n```c\nif (msg != NULL) {\n    memcpy(aux, msg, bits/8);\n} else {\n    // Handle error: source pointer is null\n    // For example, log an error or return an error code\n}\n```\n\nThis prevents the function from attempting to copy from a null pointer, which would otherwise result in a crash or undefined behavior.\n\n## In Context Remediation 2\nIf the function expects the source pointer to always be valid, consider adding an assertion to catch programming errors during development:\n\n```c\nassert(msg != NULL);\nmemcpy(aux, msg, bits/8);\n```\n\nThis will terminate the program with a clear error message if the source pointer is unexpectedly null, making it easier to identify and fix the root cause during testing.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-476"
                ]
              }
            },
            {
              "id": "743e1229-d681-3ba2-9312-5dcdd794b8a0",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and error checking. In the case of `fopen`, it is important to ensure that the `fname` parameter is a valid and secure file path, and that the file is properly handled after opening.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(fname, std::ios::binary);\nif (!file) {\n    // Handle error\n}\n```\n\nIn this example, the `std::ifstream` class from the C++ Standard Library is used instead of `fopen`. This class provides a safer and more convenient interface for file I/O.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "cf929797-df48-3d64-a5b2-28376ddbf33c",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null when the memory copy operation is performed. There are no explicit checks in the code to ensure that the pointers are valid before calling the memory copy function. The destination and source are both pointers, and there is no evidence of bounds or capacity checks. Additionally, the analysis did not detect any guards or assignments that would guarantee the pointers are non-null. This means that if either pointer is null at runtime, the program could crash or exhibit unpredictable behavior. The risk is further increased because the function verdict is marked as 'GENUINE', confirming the high confidence in this issue.\n\n## In Context Remediation\nBefore performing the memory copy operation, add explicit checks to ensure that both the source and destination pointers are not null. This prevents undefined behavior and potential crashes if either pointer is invalid.\n\n```c\nif (p != NULL && s_p != NULL) {\n    memcpy(p, s_p, n);\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\nIf the function should never receive null pointers, consider adding assertions or returning an error code if a null pointer is detected. This makes the contract of the function clear and prevents silent failures.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  },
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476",
                  "CWE-119"
                ]
              }
            },
            {
              "id": "940711d2-4ae3-3efc-876e-c9c96722c5de",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict confirms it as genuine. The code copies data from one buffer to another using a memory copy operation, but there are no explicit checks to ensure that either the source or destination pointers are not null before the operation. If either pointer is null, this will result in undefined behavior, potentially leading to a crash or security issue. The risk is further increased because the analysis detected that both the source and destination pointers may be null at this point in the code, and there are no guards or capacity checks in place.\n\n## In Context Remediation\nBefore performing the memory copy operation, add explicit checks to ensure that both the source and destination pointers are not null. This prevents undefined behavior if either pointer is invalid.\n\n```c\nif (dt_data != NULL && hat != NULL && hat->device_tree_buffer != NULL) {\n    memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size);\n} else {\n    // Handle error: one or more pointers are null\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-476"
                ]
              }
            },
            {
              "id": "ddb6b915-3c3d-3f07-943a-d6566642738f",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility of null pointers being passed as either the source or destination to the memory copy operation. The destination pointer is a raw pointer and there is no evidence of a guard or check to ensure it is not null before the operation. The source is not likely to be null, but the destination may be, which can lead to a crash or other unpredictable behavior. The absence of overlap between source and destination reduces the risk of memory corruption, but the lack of null pointer checks is a significant concern. The probability of this being a false positive is very low due to the combination of these factors.\n\n## In Context Remediation 1\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is null.\n\n```cpp\nif (meta != NULL) {\n    memcpy(meta, _read_metadata, (size_t)ret);\n} else {\n    // Handle error: destination pointer is null\n}\n```\n\nThis prevents the function from attempting to write to a null pointer, which would otherwise cause a crash or undefined behavior.\n\n## In Context Remediation 2\nIf the function expects the destination pointer to always be valid, consider adding an assertion to catch programming errors during development:\n\n```cpp\nassert(meta != NULL);\nmemcpy(meta, _read_metadata, (size_t)ret);\n```\n\nThis will terminate the program with a clear error message if the pointer is unexpectedly null, making debugging easier.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476"
                ]
              }
            },
            {
              "id": "262f4704-2e40-3e2d-8f98-5d53721f215a",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that the source pointer may be null at the point of the memory copy operation. There are no explicit checks to ensure the source pointer is valid before the copy occurs. The destination is not a pointer expression, which reduces the risk for the destination, but the lack of a guard for the source pointer is a significant concern. The operation does not involve overlapping memory regions, and the count expression is not directly tied to the capacity of the destination, which means there is no additional evidence to suggest this is a false positive. The classification and verdict both indicate a high-confidence issue.\n\n## In Context Remediation 1\nBefore performing the memory copy operation, ensure that the source pointer is not null. Add an explicit check to prevent undefined behavior if the source is invalid.\n\n```cpp\nif (buf_ != nullptr) {\n    memcpy(data + l, buf_, (len - l) * sizeof(T));\n} else {\n    // Handle error: source buffer is null\n}\n```\n\nThis check ensures that the memory copy only occurs when the source buffer is valid, preventing a potential crash or undefined behavior if the source pointer is null.\n\n## In Context Remediation 2\nIf the source buffer should never be null by design, consider adding an assertion to catch programming errors during development:\n\n```cpp\nassert(buf_ != nullptr);\nmemcpy(data + l, buf_, (len - l) * sizeof(T));\n```\n\nThis will terminate the program in debug builds if the source pointer is unexpectedly null, helping to catch bugs early.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  },
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476",
                  "CWE-119"
                ]
              }
            },
            {
              "id": "67b0eed6-849d-3378-9ad5-5c192f66c21c",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk: the destination buffer's capacity is unknown, and the amount of data being copied is not proven to be safe. The function call copies a calculated number of bytes into a destination pointer, but there is no evidence that the destination buffer is large enough to hold the copied data. There are no explicit checks or guards to ensure the destination buffer is sufficiently sized, and the count expression is not derived from a known safe value such as the size of the destination. Additionally, the destination is a pointer type with no associated capacity information, which increases the risk of a buffer overflow. The analysis also confirms that there is no risk of overlapping memory regions or null pointers at this call site, but the primary concern remains the lack of bounds checking for the destination buffer.\n\n## In Context Remediation 1\nBefore copying data, ensure that the destination buffer is large enough to hold the number of bytes specified by the copy operation. Add an explicit check to verify that the destination buffer's capacity is at least `l * sizeof(T)` bytes. If the buffer size is not known, pass the buffer size as an additional argument and check it before copying.\n\n```cpp\n// Example: Add a parameter for destination buffer size and check before memcpy\nif (dest_capacity_bytes >= l * sizeof(T)) {\n    memcpy(data, buf_ + (tail_ & (max_size_ - 1)), l * sizeof(T));\n} else {\n    // Handle error: insufficient buffer size\n}\n```\n\nIf the buffer size cannot be determined, consider using safer alternatives or redesigning the API to always provide the buffer size.\n\n\n## In Context Remediation 2\nIf the destination buffer size is not available, consider using a safer memory copy function that takes the destination buffer size as an argument, such as `memcpy_s` (if available in your environment). This function will not perform the copy if the destination buffer is too small, preventing buffer overflows.\n\n```cpp\n// Example using memcpy_s (C11 or Microsoft extension)\nmemcpy_s(data, dest_capacity_bytes, buf_ + (tail_ & (max_size_ - 1)), l * sizeof(T));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-120"
                ]
              }
            },
            {
              "id": "6c15f579-3ba0-3cd6-887b-7096230d74d0",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that the source pointer ('data') may be null when passed to the memory copy operation. There are no explicit checks in the code to ensure that the source pointer is valid before the operation. The destination is considered safe as it is not a pointer expression and is likely an object or array. The operation does not involve overlapping memory regions, which reduces the risk of data corruption, but the lack of null pointer validation for the source is a significant concern. The probability of this being a false positive is low because the verdict is marked as genuine and the classification highlights a real risk.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the source pointer ('data') is not null. Add an explicit check to prevent undefined behavior:\n\n```cpp\nif (data != NULL) {\n    memcpy(buf_ + (head_ & (max_size_ - 1)), data, l * sizeof(T));\n} else {\n    // Handle error: source pointer is null\n}\n```\nThis prevents the function from attempting to copy from a null pointer, which would otherwise result in undefined behavior and potential program crashes.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "be6b2f35-69ca-3f49-afe0-e7fd1fe6f12f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "time.sleep() call; did you mean to leave this in?"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 17,
                  "endLine": 300,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                time.sleep(0.1)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "4b46e33eaf768af0aaf08e1463b7e8874bf9fdaed028ddd2b443b7076364b6299be30f280597c8d3ef82a0bd4c784e08c03daab3b19e3d010dd4322eeefb2e9d_0"
          },
          "properties": {}
        },
        {
          "ruleId": "24724d34-6f22-307d-b193-2d2a74626e13",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "time.sleep() call; did you mean to leave this in?"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 13,
                  "endLine": 236,
                  "endColumn": 28,
                  "snippet": {
                    "text": "            time.sleep(0.5)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "82bf885a1319483f8b25e9ad6c4211cc9dfa1731f76befc989fdf76c3b1d95b31a2ff3e4eff324d5a9ad6a0da53ac66a349086792cdd21ab0565ba0d0d46aca8_0"
          },
          "properties": {}
        },
        {
          "ruleId": "ac2ed76d-d3ed-3603-920d-eddc9c82ae48",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Regex `r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)'` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 13,
                  "endLine": 15,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0c83abfeb9c0cdaecd47d7d29a6eb27faccd63214d06ef42e9f74c682c69990fef93f32f2d1d0995c47d8044f12a9e0412bb56e675e036c9e35e773cabc77b32_0"
          },
          "properties": {}
        },
        {
          "ruleId": "b9c142a0-59e6-3fc5-8591-ef43cf911bef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "time.sleep() call; did you mean to leave this in?"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 17,
                  "endLine": 275,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                time.sleep(1)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "4eb24e856a342fe479a5c7a15772b049c7f222653a3ce53e0c3e6e9ef9aab294fc20111c5479d1500dafa327baaf95e2c8c13579f815a8370a2a4576fb33faf3_0"
          },
          "properties": {}
        },
        {
          "ruleId": "df4960bd-11d2-35c7-8600-d9136ef76147",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Regex `r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)'` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 13,
                  "endLine": 24,
                  "endColumn": 74,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "d647dba260a2e8671161552175eb91a6a048472d6bb4837bd805d5f0706e6c7bdf2cb7d7634471f6f5310a0f39dceafc1fad5f5cfdbef8f437d5e35684517619_0"
          },
          "properties": {}
        },
        {
          "ruleId": "0f0db57a-28a9-3ff3-a514-977b00727cd9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Regex `r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)'` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 13,
                  "endLine": 42,
                  "endColumn": 79,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "ad81bbe6c2dec2e079b11711474eeb32fad56b6a9f1a6746779885fe282032132b4289d23f0143964f27f0427f35d333011ff82da82585b39fb4fb054f3dd808_0"
          },
          "properties": {}
        },
        {
          "ruleId": "d543ac71-bf3f-3a7a-a3bd-b4c2610b5860",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Regex `r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)'` may be vulnerable to catastrophic backtracking, which may lead to denial of service attacks. (This rule only matches regex usage, not actual REDoS patterns. For full detection, use Semgrep Pro Engine.)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 13,
                  "endLine": 33,
                  "endColumn": 74,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "cad9bbb86a0025f0d11b3cecea179c3bbe7533355cc5d816862bf937b66734fd971fbc96835dcecd70af650cb4e8de170518cb5528cd5b1cfe210bee54db9bb2_0"
          },
          "properties": {}
        },
        {
          "ruleId": "ac5751c1-904e-3519-86a1-2459014be77c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "time.sleep() call; did you mean to leave this in?"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/python/usblcd.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 5,
                  "endLine": 30,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    sleep(1)"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "65f18470f0d896ba38911d352894f22d7ce0d4c3229de7dcd91d9080e14b67c8779f6fc4a9c225a6a475a944fc9e45ecc6013629fac71a2829c3342cc963fc7f_0"
          },
          "properties": {}
        },
        {
          "ruleId": "a49ceeea-1ca7-3d5b-b986-b15ff75acc25",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 289,
                  "startColumn": 13,
                  "endLine": 289,
                  "endColumn": 18,
                  "charOffset": 9033,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2a97228f8becdfb521a9d007e70a52d01d5d553260b8d987297c11711d9680d3",
            "glog-pfp-ruleFileCode/v1": "cc5176a5c5fd7ef031bcd294a4c66a30c7f9a7cd03b166fac980398ee6a75ba1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cc5176a5c5fd7ef031bcd294a4c66a30c7f9a7cd03b166fac980398ee6a75ba1"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e7f4cdb0-194b-3405-a75e-2419864dc261",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 13,
                  "endLine": 317,
                  "endColumn": 18,
                  "charOffset": 9788,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "93433fa55cba15b5cf99e3d7eb93200dcf48b27e912e159a2bd8a9cbe9ba0b68",
            "glog-pfp-ruleFileCode/v1": "0fbde2e187ed10c1aa7ecfe160383a61f96c01c98598bbe6fa6a8a5bac0f03a0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0fbde2e187ed10c1aa7ecfe160383a61f96c01c98598bbe6fa6a8a5bac0f03a0"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "01cee931-d83f-3128-af3f-86e441e854cc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/adsb_soapy/modes.c"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 4,
                  "endLine": 385,
                  "endColumn": 28,
                  "charOffset": 13771,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(msg, aux, bits/8)",
                    "rendered": {
                      "text": "memcpy(msg, aux, bits/8)",
                      "markdown": "`memcpy(msg, aux, bits/8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7da69b0461f752a61cb4a3e63a1e1184663e835e12120d8713ab74ed408b3589",
            "glog-pfp-ruleFileCode/v1": "aa9ed3595ea37c7862edd835b5c6fa562618cdd5c10014a542446d10725616ee"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "aa9ed3595ea37c7862edd835b5c6fa562618cdd5c10014a542446d10725616ee"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/adsb_soapy/modes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13771,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(msg, <size of msg>,  aux,  bits/8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f7cfbeb6-8f6b-3b9d-bfd1-9c52b4ad1645",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/adsb_soapy/modes.c"
                },
                "region": {
                  "startLine": 469,
                  "startColumn": 2,
                  "endLine": 469,
                  "endColumn": 29,
                  "charOffset": 16916,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(aux, msg, msgbits/8)",
                    "rendered": {
                      "text": "memcpy(aux, msg, msgbits/8)",
                      "markdown": "`memcpy(aux, msg, msgbits/8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2af12a3d46cfd1ce9c003b5a8666b11a23459c710683c9a26ca42d6b24ad571c",
            "glog-pfp-ruleFileCode/v1": "8d5bae22b335f8b7f0d3c1166079503547e73b98fed18f2ad858c6530fdc9f10"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8d5bae22b335f8b7f0d3c1166079503547e73b98fed18f2ad858c6530fdc9f10"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/adsb_soapy/modes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16916,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(aux, <size of aux>,  msg,  msgbits/8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0841f7f1-721e-360b-a8fa-ddf46254c05f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/adsb_soapy/modes.c"
                },
                "region": {
                  "startLine": 371,
                  "startColumn": 3,
                  "endLine": 371,
                  "endColumn": 27,
                  "charOffset": 13334,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(aux, msg, bits/8)",
                    "rendered": {
                      "text": "memcpy(aux, msg, bits/8)",
                      "markdown": "`memcpy(aux, msg, bits/8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "62e6e67667d514059cbf3207fffb043ecf7c914bce7231b5e6c142e073670671",
            "glog-pfp-ruleFileCode/v1": "e580a08128639da348d3aa5e22781e85a8f3e950acccfd08e6c03a5c45e4e728"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "e580a08128639da348d3aa5e22781e85a8f3e950acccfd08e6c03a5c45e4e728"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/adsb_soapy/modes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13334,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(aux, <size of aux>,  msg,  bits/8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "11f83fc2-8a94-34ee-88e6-24f5bcbaf35a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/adsb_soapy/modes.c"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 3,
                  "endLine": 343,
                  "endColumn": 27,
                  "charOffset": 12600,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(msg, aux, bits/8)",
                    "rendered": {
                      "text": "memcpy(msg, aux, bits/8)",
                      "markdown": "`memcpy(msg, aux, bits/8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4336e7fb9e141462a6b2ec0c1641dd4eb547ad3ae5aa3d835801d4f0b58c9a95",
            "glog-pfp-ruleFileCode/v1": "4a29ad1d25de768eba8dc2a51d41a9d6ecdaf70197d8ec8ee0673ee8b2679b26"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4a29ad1d25de768eba8dc2a51d41a9d6ecdaf70197d8ec8ee0673ee8b2679b26"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/adsb_soapy/modes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12600,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(msg, <size of msg>,  aux,  bits/8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "86f2987b-bc22-31e8-9d65-bdebd57877de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_setup.c"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 14,
                  "endLine": 663,
                  "endColumn": 70,
                  "charOffset": 24846,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(info, &sys->board_info, sizeof(hat_board_info_st)",
                    "rendered": {
                      "text": "memcpy(info, &sys->board_info, sizeof(hat_board_info_st)",
                      "markdown": "`memcpy(info, &sys->board_info, sizeof(hat_board_info_st)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "68dc78fab1c5771024f074327acf7270e0c2c304c92190d6a77767ba00ba97ff",
            "glog-pfp-ruleFileCode/v1": "338a5a4885c3f0c490eb68a6bbe75000525c47371dcb75fd52b0662873ccd0ef"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "338a5a4885c3f0c490eb68a6bbe75000525c47371dcb75fd52b0662873ccd0ef"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/cariboulite_setup.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24846,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(info, <size of info>,  &sys->board_info,  sizeof(hat_board_info_st)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "48dbf12d-eb92-368c-817f-0c0a4b16ae55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/adsb_soapy/modes.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 2,
                  "endLine": 331,
                  "endColumn": 26,
                  "charOffset": 12221,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(aux, msg, bits/8)",
                    "rendered": {
                      "text": "memcpy(aux, msg, bits/8)",
                      "markdown": "`memcpy(aux, msg, bits/8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8db376cb383d569ab5589f8e5fb30561f9f7ce8cd56df9f5f5478c6f1e01ea49",
            "glog-pfp-ruleFileCode/v1": "ff3772332b93d8f058a8e60ccabeafdc14feee01db6199d7a39da7656139681d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ff3772332b93d8f058a8e60ccabeafdc14feee01db6199d7a39da7656139681d"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/adsb_soapy/modes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12221,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(aux, <size of aux>,  msg,  bits/8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "743e1229-d681-3ba2-9312-5dcdd794b8a0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_fs.c"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 7,
                  "endLine": 65,
                  "endColumn": 12,
                  "charOffset": 1489,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "dae9e235561846ad73a2538a9219ff7bba812d4ac69234f3e70900ef7f7ea0c7",
            "glog-pfp-ruleFileCode/v1": "a5e094fc954a8de9256bcf7499c818b7e8a470921ab7684027a4e6281b2aed30"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a5e094fc954a8de9256bcf7499c818b7e8a470921ab7684027a4e6281b2aed30"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cf929797-df48-3d64-a5b2-28376ddbf33c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                },
                "region": {
                  "startLine": 953,
                  "startColumn": 1,
                  "endLine": 953,
                  "endColumn": 18,
                  "charOffset": 31824,
                  "charLength": 17,
                  "snippet": {
                    "text": "memcpy(p, s_p, n)",
                    "rendered": {
                      "text": "memcpy(p, s_p, n)",
                      "markdown": "`memcpy(p, s_p, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ed838bedeaa4de344ffec2a56bfd334a459dae7383f1e44e5d9b554e301e763f",
            "glog-pfp-ruleFileCode/v1": "ced05eb5a0a074276d0bbc8e7b8b9c83d6b545e20770e70b7871e76b1a1c4f82"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ced05eb5a0a074276d0bbc8e7b8b9c83d6b545e20770e70b7871e76b1a1c4f82"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31824,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "memcpy_s(p, <size of p>,  s_p,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "940711d2-4ae3-3efc-876e-c9c96722c5de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 486,
                  "startColumn": 1,
                  "endLine": 486,
                  "endColumn": 71,
                  "charOffset": 14357,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)",
                    "rendered": {
                      "text": "memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)",
                      "markdown": "`memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6be5fca8df9768050088918170198bd29264b27b2f0efe851c304bf743493ae4",
            "glog-pfp-ruleFileCode/v1": "4c444ff2a1e3f0796c29d2de3897a65c5523c7af7bddc8a5b699648214b2887b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4c444ff2a1e3f0796c29d2de3897a65c5523c7af7bddc8a5b699648214b2887b"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14357,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dt_data, <size of dt_data>,  hat->device_tree_buffer,  hat->device_tree_buffer_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ddb6b915-3c3d-3f07-943a-d6566642738f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/CaribouLiteRadioCpp.cpp"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 8,
                  "endLine": 126,
                  "endColumn": 45,
                  "charOffset": 4480,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(meta, _read_metadata, (size_t)",
                    "rendered": {
                      "text": "memcpy(meta, _read_metadata, (size_t)",
                      "markdown": "`memcpy(meta, _read_metadata, (size_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cf54d935d4763fcf5515c4da477dab2136d9cdbc40cdb4585f4b223c23af4424",
            "glog-pfp-ruleFileCode/v1": "7b37f194f34c07c188fd94c38bfde435f91029c0e95e31c4a132332e2101e97e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b37f194f34c07c188fd94c38bfde435f91029c0e95e31c4a132332e2101e97e"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/CaribouLiteRadioCpp.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4480,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(meta, <size of meta>,  _read_metadata,  (size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "262f4704-2e40-3e2d-8f98-5d53721f215a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 3,
                  "endLine": 88,
                  "endColumn": 35,
                  "charOffset": 1969,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(data + l, buf_, (len - l)",
                    "rendered": {
                      "text": "memcpy(data + l, buf_, (len - l)",
                      "markdown": "`memcpy(data + l, buf_, (len - l)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1b4c8b49b78ec904fa61d3114f7de16ba27a2a3a9306a29adda5f32bfd666605",
            "glog-pfp-ruleFileCode/v1": "83c33227c03f1de358dbc223cf930c30285f7d28c7ac23a54f17f370cd0c0521"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "83c33227c03f1de358dbc223cf930c30285f7d28c7ac23a54f17f370cd0c0521"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1969,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data + l, <size of data + l>,  buf_,  (len - l)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "67b0eed6-849d-3378-9ad5-5c192f66c21c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 3,
                  "endLine": 87,
                  "endColumn": 63,
                  "charOffset": 1903,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(data, buf_ + (tail_ & (max_size_ - 1)), l * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(data, buf_ + (tail_ & (max_size_ - 1)), l * sizeof(T)",
                      "markdown": "`memcpy(data, buf_ + (tail_ & (max_size_ - 1)), l * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0ad5ef9a7cb80435cb69e176c084ca8e35cf8e63f1b924ef7fa54be0cb1219a4",
            "glog-pfp-ruleFileCode/v1": "f4c5af164d5ab7ad909a6bacde5b807f1092b2dcfaef3c2d20aabd4f6125e610"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f4c5af164d5ab7ad909a6bacde5b807f1092b2dcfaef3c2d20aabd4f6125e610"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1903,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data, <size of data>,  buf_ + (tail_ & (max_size_ - 1)),  l * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c15f579-3ba0-3cd6-887b-7096230d74d0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 2,
                  "endLine": 50,
                  "endColumn": 62,
                  "charOffset": 1081,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(buf_ + (head_ & (max_size_ - 1)), data, l * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(buf_ + (head_ & (max_size_ - 1)), data, l * sizeof(T)",
                      "markdown": "`memcpy(buf_ + (head_ & (max_size_ - 1)), data, l * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f54ee7f4bbcbdd8edefd4634d0c8d466501ba51be3d981326bf5c3eaf191b3fb",
            "glog-pfp-ruleFileCode/v1": "d3548d6183cec9906f24c42974c23a25e86ce326db3563f199a2809335a89bd4"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d3548d6183cec9906f24c42974c23a25e86ce326db3563f199a2809335a89bd4"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/datatypes/circular_buffer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1081,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf_ + (head_ & (max_size_ - 1)), <size of buf_ + (head_ & (max_size_ - 1))>,  data,  l * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}