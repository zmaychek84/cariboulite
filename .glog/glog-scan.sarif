{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "e7f4cdb0-194b-3405-a75e-2419864dc261",
              "name": "\"Prohibited C Function Identified\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. In this case, the function `fopen()` is used with the \"w\" mode, which opens a file for writing. If the file already exists, its contents are discarded and the file is treated as a new empty file. This can lead to potential data loss if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen()`. In C++, the safer alternative is to use the file stream classes (`fstream`, `ifstream`, `ofstream`) provided by the Standard Library. These classes provide better control over file operations and are less prone to errors.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `ofstream`:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library that provides facilities for file-based input and output.\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "be6b2f35-69ca-3f49-afe0-e7fd1fe6f12f",
              "name": "Unintended time.sleep() function call vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `time.sleep()` function in Python is used to delay the execution of the next line of code for a specified amount of time. The \"Unintended time.sleep() function call\" vulnerability occurs when an attacker is able to manipulate the input to the `time.sleep()` function, causing the application to pause for an extended period of time. This can lead to Denial of Service (DoS) attacks, where the application becomes unresponsive or slow to respond.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user-supplied input directly in the `time.sleep()` function. If a delay is necessary, it should be a fixed value defined by the application, not by the user. \n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```python\nimport time\n\ntime.sleep(0.1)\n```\n\nUse a fixed value:\n\n```python\nimport time\n\nfixed_delay = 0.1\ntime.sleep(fixed_delay)\n```\n\nIn this case, the delay is fixed and cannot be manipulated by an attacker.\n\n## Library Dependencies\n\nThe code example requires the built-in Python library `time`.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "d0fa257c-edeb-34b5-957b-b1b28f3517e0",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if not used properly. \n\nThe `fopen` function is used to open a file, but it does not check for any permissions or restrictions. This can lead to unauthorized file access or disclosure of information if the file contains sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For example, instead of `fopen`, you can use `fopen_s` which is a safer version of `fopen`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, \"/proc/cpuinfo\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `stdio.h`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "24724d34-6f22-307d-b193-2d2a74626e13",
              "name": "Unintended time.sleep() function call vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `time.sleep()` function in Python is used to delay the execution of the next line of code for a specified amount of seconds. An unintended `time.sleep()` function call vulnerability occurs when an attacker is able to manipulate the input to the `time.sleep()` function, causing the application to pause for an extended period of time. This can lead to Denial of Service (DoS) attacks, where the application becomes unresponsive or slow to respond.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user-supplied input directly in the `time.sleep()` function. If a delay is necessary, consider using a fixed value that cannot be manipulated by an attacker. \n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```python\nimport time\ntime.sleep(0.5)\n```\n\nUse a fixed value:\n\n```python\nimport time\nfixed_delay = 0.5\ntime.sleep(fixed_delay)\n```\n\n## Library Dependencies\n\nThe code example requires the built-in Python library `time`.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "b9c142a0-59e6-3fc5-8591-ef43cf911bef",
              "name": "Unintended time.sleep() function call vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `time.sleep()` function in Python is used to delay the execution of the next line of code for a specified number of seconds. An unintended `time.sleep()` function call vulnerability occurs when this function is used inappropriately, causing unnecessary delays in the execution of the program. This can lead to Denial of Service (DoS) attacks, where an attacker can exploit these delays to make the system unresponsive.\n\n## Mitigation Advice\n\nAvoid using `time.sleep()` function in your code unless it's absolutely necessary. If you must use it, ensure that the delay time is not too long to prevent the system from becoming unresponsive. Also, ensure that the delay time is not controlled by user input to prevent an attacker from setting it to a high value.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```python\nimport time\n\ntime.sleep(1)\n```\n\nYou can use a non-blocking delay like this:\n\n```python\nimport asyncio\n\nasync def main():\n    await asyncio.sleep(1)\n\nasyncio.run(main())\n```\n\n## Library Dependencies\n\nThe code example requires the `time` library which is a built-in library in Python, so no additional installation is needed.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "dbeafd82-8ae1-3c0e-a39b-a5799a536a4a",
              "name": "Detected Vulnerability in C Function (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is used to copy the contents of a `struct tm` object returned by `gmtime` into `T`. If `T` is not large enough to hold the contents of the `struct tm` object, a buffer overflow can occur.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, do not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nInstead of using `memcpy`, you can directly assign the result of `gmtime` to `T` if `T` is of type `struct tm*`. Here is the corrected code:\n\n```cpp\nT = gmtime(&time_now);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `ctime`: This library provides the `gmtime` function which converts a time in seconds to a `struct tm` object.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "a49ceeea-1ca7-3d5b-b986-b15ff75acc25",
              "name": "\"Prohibited C Function Identified\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. In this case, the function `fopen()` is used with the \"w\" mode, which opens a file for writing. If the file already exists, its contents are discarded and the file is treated as a new empty file. This can lead to potential data loss if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen()`. In C++, the safer alternative is to use the file stream classes (`fstream`, `ifstream`, `ofstream`) provided by the Standard Library. These classes provide better control over file operations and are less prone to errors.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `ofstream`:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library that provides facilities for file-based input and output.\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "d543ac71-bf3f-3a7a-a3bd-b4c2610b5860",
              "name": "Potential Catastrophic Backtracking Vulnerability in Regex `r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)'` May Lead to Denial of Service Attacks",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe regular expression `r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)'` in Python's `re` module is vulnerable to a potential catastrophic backtracking vulnerability. This vulnerability can lead to Denial of Service (DoS) attacks. \n\nCatastrophic backtracking occurs when a regular expression engine enters a state of excessive backtracking due to inefficiently written regex patterns. This can cause the regex engine to consume an excessive amount of computational resources, leading to a DoS condition.\n\nIn this specific case, the regex pattern `([^\\s]*)` is prone to excessive backtracking. This pattern matches any character that is not a whitespace character, and the `*` quantifier means \"zero or more times\". This can lead to a large number of possible matches, causing the regex engine to backtrack excessively when trying to find a match.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using greedy quantifiers like `*` in your regex patterns. Instead, use non-greedy quantifiers like `*?`, `+?`, or `??`, which will stop matching as soon as they find a match.\n\nYou should also consider using atomic grouping or possessive quantifiers, which prevent the regex engine from backtracking. However, these features are not available in Python's `re` module, so you may need to use a third-party regex library that supports them, such as the `regex` library.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```python\nimport re\n\nm = re.search(r'BINDTOOL_HEADER_FILE\\(([^\\s]*?)\\)', self.file_txt)\n```\n\nIn this version, the `*` quantifier is replaced with `*?`, making it non-greedy.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- Python's built-in `re` module\n\n## OWASP and CWE Links\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "ac2ed76d-d3ed-3603-920d-eddc9c82ae48",
              "name": "Potential vulnerability to catastrophic backtracking in Regex `r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)'` may result in denial of service attacks.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe regular expression `r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)'` in Python's `re` module is vulnerable to catastrophic backtracking. This can lead to a Denial of Service (DoS) attack if an attacker provides a specially crafted input that causes the regular expression engine to consume excessive resources, such as CPU and memory, while trying to match the input.\n\nCatastrophic backtracking occurs when a regular expression has multiple, ambiguous ways to match an input, causing the regex engine to try all possible combinations, which can be exponential in the size of the input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using regular expressions that can lead to catastrophic backtracking. This typically involves avoiding nested quantifiers and using non-greedy quantifiers where possible.\n\n## Source Code Fix Recommendation\n\nIn this specific case, the regular expression can be fixed by changing the `([^\\s])` part to `([^\\s]+?)`. This makes the quantifier non-greedy, so it will match the minimum number of characters necessary, reducing the risk of catastrophic backtracking.\n\nHere is the fixed code:\n\n```python\nimport re\n\nm = re.search(r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s]+?)\\)', self.file_txt)\n```\n\n## Library Dependencies\n\nThe code example requires the `re` module, which is part of Python's standard library, so no additional dependencies are needed.\n\n## References\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "981fbd69-fa76-3376-b3fc-78535df301e6",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the `fprintf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these insecure C library functions. For instance, instead of using `fprintf`, consider using `snprintf` or `vsnprintf` which are safer as they take an additional parameter that specifies the size of the destination buffer, thus preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"\\t%s: \\\"%s\\\"\\n\", prod->tests[i].test_name, prod->tests[i].test_result_textual);\nfputs(buffer, fid);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdio.h`: for `fprintf` and `fputs` functions\n- `stdlib.h`: for dynamic memory allocation and deallocation if used elsewhere in the code\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "af134eba-b07e-3963-9583-68ad69166e70",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow vulnerability. This can lead to crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen` such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Assuming prod->git_pat_pass is a null-terminated string\nsize_t len = strnlen(prod->git_pat_pass, MAX_LENGTH);\n\n// If prod->git_pat_pass might not be null-terminated\nchar safe_string[MAX_LENGTH + 1];\nstrncpy(safe_string, prod->git_pat_pass, MAX_LENGTH);\nsafe_string[MAX_LENGTH] = '\\0';\nsize_t len = strlen(safe_string);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length that `prod->git_pat_pass` can be. This ensures that `strnlen` and `strncpy` do not read past the end of `prod->git_pat_pass`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `#include <cstring>` for `strlen`, `strnlen`, and `strncpy`\n- `#include <cstddef>` for `size_t`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "ac5751c1-904e-3519-86a1-2459014be77c",
              "name": "Unintended time.sleep() function call vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `time.sleep()` function in Python is used to delay the execution of the next line of code for a specified amount of time. An unintended `time.sleep()` function call vulnerability occurs when this function is used inappropriately, causing unnecessary delays in the execution of the program. This can lead to Denial of Service (DoS) attacks, where an attacker can exploit these delays to make the system unresponsive.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `time.sleep()` function in your code unless it's absolutely necessary. If you must use it, ensure that the delay time is not too long to prevent the system from becoming unresponsive. Also, validate and sanitize all inputs to the `time.sleep()` function to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```python\nimport time\n\ntime.sleep(1)\n```\n\nYou can use a conditional statement to control when the `time.sleep()` function is called:\n\n```python\nimport time\n\n# Some condition\nif condition:\n    time.sleep(1)\n```\n\n## Library Dependencies\n\nThe `time` module is a built-in module in Python, so no additional library dependencies are required.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "9acc7217-14a6-3e9a-846e-09d2333e2036",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(prod->git_pat_user)` could lead to a vulnerability if `prod->git_pat_user` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Be cautious when dealing with user-supplied input or data from untrusted sources. Consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Assuming prod->git_pat_user is a char array\nif (prod->git_pat_user != NULL) {\n    len = strnlen(prod->git_pat_user, MAX_LENGTH);\n} else {\n    // Handle error\n}\n```\n\nIn this code, `MAX_LENGTH` should be the maximum length of `prod->git_pat_user` that you expect. If `prod->git_pat_user` is longer than `MAX_LENGTH`, `strnlen` will stop reading after `MAX_LENGTH` characters, preventing potential buffer overflows.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed for this code to execute.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "df4960bd-11d2-35c7-8600-d9136ef76147",
              "name": "Potential Denial of Service Vulnerability in Regex `r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)'` due to Catastrophic Backtracking",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe regular expression `r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)'` in Python's `re` module is vulnerable to a potential Denial of Service (DoS) attack due to catastrophic backtracking. Catastrophic backtracking occurs when a regular expression takes a very long time to evaluate, potentially leading to a DoS attack if an attacker can control the input.\n\nIn this case, the regular expression `([^\\s])` is trying to match any character that is not a whitespace character. However, it only matches one character due to the lack of a quantifier such as `*` or `+`. If the input string is very long and does not contain a whitespace character, the regular expression engine will backtrack excessively, leading to a potential DoS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using regular expressions that can lead to catastrophic backtracking. In this case, you can modify the regular expression to include a quantifier that specifies how many non-whitespace characters to match. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```python\nimport re\n\nm = re.search(r'BINDTOOL_USE_PYGCCXML\\(([^\\s]+)\\)', self.file_txt)\n```\n\nIn this version, the `+` quantifier is used to match one or more non-whitespace characters, preventing catastrophic backtracking.\n\n## Library Dependencies\n\nThe code example requires the `re` module, which is included in the Python Standard Library.\n\n## OWASP and CWE Resources\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "b5eff820-aaa1-3b44-9222-0389fb5b0274",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. This is why the use of `strcpy` is often prohibited in secure coding standards.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. These include `strncpy`, `strlcpy`, or `memcpy`. However, these functions also have their own caveats and must be used correctly.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` function, which includes the size of the destination buffer as a parameter:\n\n```cpp\nstrncpy(prod->git_res_directory, dir, sizeof(prod->git_res_directory));\nprod->git_res_directory[sizeof(prod->git_res_directory) - 1] = '\\0'; // Ensure null termination\n```\n\nNote that `strncpy` does not null-terminate the destination string if the source string is longer than the specified size. Therefore, you should manually null-terminate the destination string to prevent potential issues.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "c65aaffe-3eed-3934-bd2a-cc08b84064ac",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use safer string copy functions that include buffer size as a parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions ensure that no more than the specified number of bytes is written to the destination buffer, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(prod->git_repo, repo, sizeof(prod->git_repo));\nprod->git_repo[sizeof(prod->git_repo) - 1] = '\\0'; // Ensure null termination\n```\n\nThis code will copy at most `sizeof(prod->git_repo)` characters from `repo` to `prod->git_repo`, and ensures that the destination string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "fb6898e6-6a4c-3462-a7a1-03216b7e647c",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using functions that take the size of the buffer as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nIf `i` is intended to hold the length of a string `str`, the code should look like this:\n\n```cpp\nchar str[] = \"example\";\nsize_t i = strnlen(str, sizeof(str));\n```\n\nIn this example, `strnlen` will not read past the size of `str`, preventing potential buffer overflows.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "0f0db57a-28a9-3ff3-a514-977b00727cd9",
              "name": "Potential for catastrophic backtracking vulnerability in Regex `r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)'` leading to denial of service attacks.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe regular expression `r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)'` in Python's `re` module is vulnerable to a potential catastrophic backtracking issue. This vulnerability can lead to Denial of Service (DoS) attacks. \n\nCatastrophic backtracking occurs when a regular expression engine enters a state of excessive recursion while attempting to match an input string with a regular expression. This can cause the application to consume an excessive amount of CPU time, leading to a DoS condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using regular expressions that can cause excessive backtracking. This can be achieved by:\n\n- Avoiding nested quantifiers and making sure that the regular expression is as specific as possible.\n- Using atomic grouping or possessive quantifiers to prevent the regular expression engine from backtracking.\n- Limiting the input size for the regular expression.\n\n## Source Code Fix Recommendation\n\nIn this specific case, the regular expression can be fixed by making it more specific and avoiding the nested quantifier. Here is a possible fix:\n\n```python\nm = re.search(r'BINDTOOL_HEADER_FILE_HASH\\((\\S+)\\)', self.file_txt)\n```\n\nIn this fixed version, `\\S+` matches any non-whitespace character one or more times, which is more specific than `[^\\s]*`.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `re` (built-in Python library for regular expressions)\n\n## References\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "981064e6-83cc-3df1-8c8a-c3a9673d5957",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is manipulated or if the file is not properly closed after use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fstream` objects from the C++ Standard Library, which automatically handle file closing and can provide more robust error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ifstream` object from the C++ Standard Library. Here is an example of how to do this:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(prod->git_pat_path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "65369937-efb7-34e6-8a5a-eb20ac25cc8f",
              "name": "Unintended time.sleep() function call vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `time.sleep()` function in Python is used to delay the execution of the next line of code for a specified number of seconds. An unintended `time.sleep()` function call vulnerability occurs when this function is used inappropriately, causing unnecessary delays in the execution of the program. This can lead to Denial of Service (DoS) attacks, where an attacker can exploit these delays to make the system unresponsive.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using `time.sleep()` function in production code unless it is absolutely necessary. If it is necessary, ensure that the sleep duration is not controlled by user inputs or any external factors that can be manipulated by an attacker. \n\n## Source Code Fix Recommendation\n\nIn the given code snippet, `time.sleep(2.0)` is causing a delay of 2 seconds. If this delay is not necessary, simply remove this line of code. If the delay is necessary, ensure that the duration is not influenced by user inputs or external factors.\n\n```python\n# Remove if not necessary\n# time.sleep(2.0)\n```\n\n## Library Dependencies\n\nThe `time` module is a built-in module in Python, so no additional library dependencies are required for the `time.sleep()` function to execute properly.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "9036fca4-3351-3090-8910-71b1b5b1bcd4",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to a buffer overflow if the string is not null-terminated. In the provided code snippet, `strlen(msg)` is used to determine the length of the message to be sent with `zmq_send`. If `msg` is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte at the end, or by manually adding a null byte at the end of your strings before using functions like `strlen`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strlen` is `strnlen`, which takes an additional parameter specifying the maximum length of the string. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the string.\n\nHere's how you can modify the provided code snippet to use `strnlen`:\n\n```cpp\nsize_t msg_len = strnlen(msg, MAX_MSG_LEN);\nzmq_send(dev->requester, msg, msg_len, 0);\n```\n\nIn this code, `MAX_MSG_LEN` is a constant that you should define somewhere in your program, representing the maximum length of a message.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- ZeroMQ: A high-performance asynchronous messaging library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "c5406586-cb50-3e87-9f77-f54888437b3a",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to a buffer overflow if the string is not null-terminated. In the provided code snippet, `strlen(msg)` is used to determine the length of the message to be sent with `zmq_send`. If `msg` is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte at the end, or by manually adding a null byte at the end of your strings before using functions like `strlen`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strlen` is `strnlen`, which takes an additional parameter specifying the maximum length of the string. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the string.\n\nHere's how you can modify the provided code snippet to use `strnlen`:\n\n```cpp\nsize_t msg_len = strnlen(msg, MAX_MSG_LEN);\nzmq_send(dev->requester, msg, msg_len, 0);\n```\n\nIn this code, `MAX_MSG_LEN` is a constant that you should define somewhere in your program, representing the maximum length of a message.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- ZeroMQ: A high-performance asynchronous messaging library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "6661d5c7-64d0-3ffd-9242-a975069705b0",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to a buffer overflow if the string is not null-terminated. In the provided code snippet, `strlen(msg)` is used to determine the length of the message to be sent with `zmq_send`. If `msg` is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte at the end, or by manually adding a null byte at the end of your strings before using functions like `strlen`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strlen` is `strnlen`, which takes an additional parameter specifying the maximum length of the string. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the string.\n\nHere's how you can modify the provided code snippet to use `strnlen`:\n\n```cpp\nsize_t msg_len = strnlen(msg, MAX_MSG_LEN);\nzmq_send(dev->requester, msg, msg_len, 0);\n```\n\nIn this code, `MAX_MSG_LEN` is a constant that you should define somewhere in your program, representing the maximum length of a message.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- ZeroMQ: A high-performance asynchronous messaging library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "c6c388e1-3736-34a9-bdf4-df6e289fa46c",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strcpy` and instead use safer string handling functions that include buffer size as a parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions prevent buffer overflow by ensuring that no more than the specified number of bytes is written to the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(prod->git_pat_path, pat, sizeof(prod->git_pat_path) - 1);\nprod->git_pat_path[sizeof(prod->git_pat_path) - 1] = '\\0';\n```\n\nThis code will copy the string from `pat` to `prod->git_pat_path`, but it will not write more than `sizeof(prod->git_pat_path) - 1` bytes. The last line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "29f3f252-d886-378b-b8f3-d7828f439ae4",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fstream` objects from the C++ Standard Library, which provide a higher level of abstraction and are generally safer.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` object from the C++ Standard Library. Here is how you can do it:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(state.filename, std::ios::binary);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a part of the C++ Standard Library and provides facilities for file-based input and output.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "aa305e1b-337b-3449-9622-b45ccc723d04",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a C library function that converts a string argument to an integer. The problem with `atoi()` is that it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that can handle errors properly. In C++, you can use `std::stoi()`, which throws an exception if the conversion fails. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(optarg)` with `std::stoi(optarg)`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    int value = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-242",
                    "url": "https://cwe.mitre.org/data/definitions/242.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-242"
                ]
              }
            },
            {
              "id": "b59de62f-3e57-3ac6-a6ad-a1814c69eb25",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to a buffer overflow if the string is not null-terminated. In the provided code snippet, `strlen(msg)` is used to determine the length of the message to be sent with `zmq_send`. If `msg` is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte at the end, or by manually adding a null byte at the end of your strings before using functions like `strlen`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strlen` is `strnlen`, which takes an additional parameter specifying the maximum length of the string. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the string.\n\nHere's how you can modify the provided code snippet to use `strnlen`:\n\n```cpp\nsize_t msg_len = strnlen(msg, MAX_MSG_LEN);\nzmq_send(dev->requester, msg, msg_len, 0);\n```\n\nIn this code, `MAX_MSG_LEN` is a constant that you should define somewhere in your program, representing the maximum length of a message.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- ZeroMQ: A high-performance asynchronous messaging library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "928edd49-be3e-3221-ba1e-a4e4157729d3",
              "name": "\"Production Code Debugging Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Code Debugging Vulnerability\" in C++ refers to the situation where debugging code or debugging entry points are accidentally left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In the provided code example, the vulnerability sink is the `zmq_connect` function, which is used to establish a connection to a specific TCP port on localhost.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that all debugging code is properly removed or disabled before the code is deployed to a production environment. This includes any code that opens up unnecessary network connections, writes sensitive information to logs, or provides any other form of access or information that would not be necessary in a production environment.\n\n## Source Code Fix Recommendation\n\nIn the provided code example, the `zmq_connect` function is used to establish a connection to a specific TCP port on localhost. If this is debugging code, it should be removed or disabled in the production environment. This can be done by using preprocessor directives to ensure that the code is only compiled in a debug build, not in a release build.\n\n```cpp\n#ifdef DEBUG\nzmq_connect (dev->requester, \"tcp://localhost:55550\");\n#endif\n```\n\n## Library Dependencies\n\nThe provided code example requires the ZeroMQ library to execute properly.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-489",
                    "url": "https://cwe.mitre.org/data/definitions/489.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-489"
                ]
              }
            },
            {
              "id": "26244ae6-7a84-352e-996f-4a11db4473b1",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atof(optarg)` is used, which converts a string to a double. This function does not check for overflow or underflow, and does not report errors, making it a potential security risk.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or error reporting. Instead, use safer alternatives provided by the C++ Standard Library. In this case, you can use `std::stod` function which throws an exception if the conversion cannot be performed or if the converted value would fall out of the range of the result type.\n\n## Source Code Fix Recommendation\n\nReplace `atof(optarg)` with `std::stod(optarg)`. Here is an example:\n\n```cpp\n#include <string>\n\ntry {\n    double value = std::stod(optarg);\n} catch (const std::invalid_argument& ia) {\n    // Handle invalid argument\n} catch (const std::out_of_range& oor) {\n    // Handle out of range error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-242",
                    "url": "https://cwe.mitre.org/data/definitions/242.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-242"
                ]
              }
            },
            {
              "id": "53386e6f-2dd7-3ade-bb10-d9e9e94768b5",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atof(optarg)` is used, which converts a string to a double. This function does not check for overflow or underflow, and does not report errors, making it a potential security risk.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or error reporting. Instead, use safer alternatives provided by the C++ Standard Library. In this case, you can use `std::stod` function which throws an exception if the conversion cannot be performed or if the converted value would fall out of the range of the result type.\n\n## Source Code Fix Recommendation\n\nReplace `atof(optarg)` with `std::stod(optarg)`. Here is an example:\n\n```cpp\n#include <string>\n\ntry {\n    double value = std::stod(optarg);\n} catch (const std::invalid_argument& ia) {\n    // Handle invalid argument\n} catch (const std::out_of_range& oor) {\n    // Handle out of range error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-242",
                    "url": "https://cwe.mitre.org/data/definitions/242.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-242"
                ]
              }
            },
            {
              "id": "c7243d19-dadc-3f85-a168-ef29f12f99c9",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the static analysis tool detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source expressions are derived from the same base object, which means there is a realistic chance that the memory regions could overlap. The use of memcpy in such cases is unsafe, as its behavior is undefined when source and destination overlap. The verdict is supported by the classification and the tool's high-confidence 'GENUINE' verdict. There are no explicit runtime checks or guards to prevent overlap, and the code does not use a safer alternative such as memmove. The probability of this being a false positive is low, as the analysis found concrete evidence of potential overlap and no mitigating factors such as null pointers or explicit bounds checks.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory regions that may overlap, add a runtime check to ensure the source and destination do not overlap before using memcpy. If overlap is possible, use memmove instead, which is safe for overlapping regions.\n\n```c\nif ((char *)&radio->interrupts + sizeof(cariboulite_radio_irq_st) <= (char *)((radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24)) ||\n    (char *)((radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24)) + sizeof(cariboulite_radio_irq_st) <= (char *)&radio->interrupts) {\n    memcpy(&radio->interrupts, (radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24), sizeof(cariboulite_radio_irq_st));\n} else {\n    memmove(&radio->interrupts, (radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24), sizeof(cariboulite_radio_irq_st));\n}\n```\n\n\n## In Context Remediation 2\nAlternatively, replace the memcpy call with memmove, which is designed to handle overlapping memory regions safely:\n\n```c\nmemmove(&radio->interrupts, (radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24), sizeof(cariboulite_radio_irq_st));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  },
                  {
                    "id": "CWE-787",
                    "url": "https://cwe.mitre.org/data/definitions/787.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-120",
                  "CWE-787"
                ]
              }
            },
            {
              "id": "20cef17f-0569-36b0-a7ae-5d6b891d1432",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atof(optarg)` is used, which converts a string to a double. This function does not check for overflow or underflow, and does not report errors, making it a potential security risk.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or error reporting. Instead, use safer alternatives provided by the C++ Standard Library. In this case, you can use `std::stod` function which throws an exception if the conversion cannot be performed or if the converted value would fall out of the range of the result type.\n\n## Source Code Fix Recommendation\n\nReplace `atof(optarg)` with `std::stod(optarg)`. Here is an example:\n\n```cpp\n#include <string>\n\ntry {\n    double value = std::stod(optarg);\n} catch (const std::invalid_argument& ia) {\n    // Handle invalid argument\n} catch (const std::out_of_range& oor) {\n    // Handle out of range error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-242",
                    "url": "https://cwe.mitre.org/data/definitions/242.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-242"
                ]
              }
            },
            {
              "id": "31d466ee-d714-3a5a-9532-9983758b5bd7",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a C library function that converts a string argument to an integer. The problem with `atoi()` is that it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that can handle errors properly. In C++, you can use `std::stoi()`, which throws an exception if the conversion fails. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(optarg)` with `std::stoi(optarg)`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    int value = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-242",
                    "url": "https://cwe.mitre.org/data/definitions/242.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-242"
                ]
              }
            },
            {
              "id": "cf929797-df48-3d64-a5b2-28376ddbf33c",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null when the memory copy operation is performed. There are no explicit checks in the code to ensure that the pointers are valid before calling the memory copy function. The destination and source are both pointers, and there is no evidence of bounds or capacity checks. Additionally, the analysis did not detect any guards or assignments that would guarantee the pointers are non-null. This means that if either pointer is null at runtime, the program could crash or exhibit unpredictable behavior. The risk is further increased because the function verdict is marked as 'GENUINE', confirming the high confidence in this issue.\n\n## In Context Remediation\nBefore performing the memory copy operation, add explicit checks to ensure that both the source and destination pointers are not null. This prevents undefined behavior and potential crashes if either pointer is invalid.\n\n```c\nif (p != NULL && s_p != NULL) {\n    memcpy(p, s_p, n);\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\nIf the function should never receive null pointers, consider adding assertions or returning an error code if a null pointer is detected. This makes the contract of the function clear and prevents silent failures.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  },
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476",
                  "CWE-119"
                ]
              }
            },
            {
              "id": "ddb6b915-3c3d-3f07-943a-d6566642738f",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility of null pointers being passed as either the source or destination to the memory copy operation. The destination pointer is a raw pointer and there is no evidence of a guard or check to ensure it is not null before the operation. The source is not likely to be null, but the destination may be, which can lead to a crash or other unpredictable behavior. The absence of overlap between source and destination reduces the risk of memory corruption, but the lack of null pointer checks is a significant concern. The probability of this being a false positive is very low due to the combination of these factors.\n\n## In Context Remediation 1\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is null.\n\n```cpp\nif (meta != NULL) {\n    memcpy(meta, _read_metadata, (size_t)ret);\n} else {\n    // Handle error: destination pointer is null\n}\n```\n\nThis prevents the function from attempting to write to a null pointer, which would otherwise cause a crash or undefined behavior.\n\n## In Context Remediation 2\nIf the function expects the destination pointer to always be valid, consider adding an assertion to catch programming errors during development:\n\n```cpp\nassert(meta != NULL);\nmemcpy(meta, _read_metadata, (size_t)ret);\n```\n\nThis will terminate the program with a clear error message if the pointer is unexpectedly null, making debugging easier.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476"
                ]
              }
            },
            {
              "id": "14982622-55fb-3813-9644-5bfc097eab48",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use safer string copy functions that include a length parameter. This allows the function to ensure that it does not write past the end of the buffer. Functions like `strncpy`, `strlcpy` or `memcpy` can be used instead, but they must be used correctly to ensure they are safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with a safer function like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(info->revision, revision, sizeof(info->revision) - 1);\ninfo->revision[sizeof(info->revision) - 1] = '\\0';\n```\n\nThis code will copy the string from `revision` to `info->revision`, but it will not write past the end of `info->revision`. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe `strncpy` function is part of the C standard library, so you don't need any additional libraries beyond what you would normally need for a C++ program.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "86f2987b-bc22-31e8-9d65-bdebd57877de",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that the destination pointer may be null, and there are no explicit checks to prevent this. The analysis shows that the destination pointer ('info') could be null at the point of the memory copy operation, and there is no guard in place to ensure it is valid. The source pointer is safe, as it is always non-null due to being the address of a structure member. The use of 'memcpy' with a potentially null destination pointer can lead to a crash or other undefined behavior. The probability of this being a false positive is low, as the risk is clearly present and not mitigated by any checks or safe usage patterns.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is invalid.\n\n```c\nif (info != NULL) {\n    memcpy(info, &sys->board_info, sizeof(hat_board_info_st));\n} else {\n    // Handle error: destination pointer is null\n    // For example, log an error or return an error code\n}\n```\n\nThis check ensures that the function does not attempt to write to a null pointer, which would otherwise cause a crash or undefined behavior.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "0a608345-3c7e-3587-87e5-5f378174394c",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the null-terminating character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows or other memory corruption issues.\n\nIn the given code `(len = strlen(revision)) == 0`, the vulnerability arises if `revision` is not a null-terminated string. This could lead to undefined behavior, including reading beyond the allocated memory, which could lead to a security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate the string for you.\n\nAlso, consider using safer alternatives to `strlen` such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered. This can prevent buffer overflows by ensuring that `strnlen` does not read beyond the specified length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif(revision != NULL) {\n    len = strnlen(revision, MAX_LENGTH);\n    if(len == 0) {\n        // Handle the case where the string is empty\n    }\n} else {\n    // Handle the case where the string is NULL\n}\n```\n\nIn this code, `MAX_LENGTH` should be the maximum length that `revision` can be. This ensures that `strnlen` does not read beyond this length, preventing potential buffer overflows.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "dcb67dee-15a9-3a7d-b3dc-0958b6b0c59d",
              "name": "Detected Vulnerability in C Function (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy(msg->p, ZF_LOG_EOL, eol_len)`, if `eol_len` is larger than the size of `msg->p`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow. For example, `strncpy` or `snprintf` in C, or `std::copy` in C++.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif (eol_len <= sizeof(msg->p)) {\n    memcpy(msg->p, ZF_LOG_EOL, eol_len);\n} else {\n    // Handle error condition, e.g., by truncating or aborting\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code snippet.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "fe99c9e3-bc1a-381d-9347-73a78828a825",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use safer string copy functions that include a length parameter. This allows the function to ensure that it does not write past the end of the buffer. Functions like `strncpy`, `strlcpy` or `memcpy` can be used instead, but they must be used correctly to ensure they are safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with a safer function like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(info->revision, revision, sizeof(info->revision) - 1);\ninfo->revision[sizeof(info->revision) - 1] = '\\0';\n```\n\nThis code will copy the string from `revision` to `info->revision`, but it will not write past the end of `info->revision`. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe `strncpy` function is part of the C standard library, so you don't need any additional libraries beyond what you would normally need for a C++ program.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "48e6f013-60b9-3a3b-ae5d-3181fa968681",
              "name": "\"Prohibited C Function Identified\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential for causing buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path or mode is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. For instance, consider using the `fopen_s` function, which is a safer version of `fopen`. It's also important to validate and control the file path and mode used with these functions to prevent potential security issues.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `fopen_s`:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, \"/proc/device-tree/system/linux,revision\", \"r\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` library to execute properly.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "97f4f93a-c0de-3922-afad-3ab219c9913c",
              "name": "Detected Prohibited C Function",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if not used properly. \n\nThe `fopen` function is used to open a file, but it does not check for any permissions or restrictions. This can lead to unauthorized file access or disclosure of information if the file contains sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For example, instead of `fopen`, you can use `fopen_s` which is a safer version of `fopen`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, \"/proc/cpuinfo\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `stdio.h`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-676"
                ]
              }
            },
            {
              "id": "121f44f2-49dc-3c56-8d37-83dd08c35f4f",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. This function is used to calculate the length of a string, but it does not count the null character at the end of the string. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen()` function is used to calculate the length of `dev_type`. To fix this vulnerability, you could use `strnlen()` instead:\n\n```cpp\nio_utils_write_to_file(sys_dir_bus_del_dev, dev_type, strnlen(dev_type, MAX_LENGTH) + 1) != 0\n```\n\nIn this code, `MAX_LENGTH` should be replaced with the maximum expected length of `dev_type`. This will prevent `strnlen()` from reading past the end of `dev_type`, even if it is not null-terminated.\n\n## Library Dependencies\n\nThe provided code snippet appears to be using a custom function `io_utils_write_to_file()`, so it's not clear what libraries it might depend on. However, the `strlen()` function is part of the C standard library, so the code will need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "7fe84cfc-fffa-3c24-9365-83d84bcd12c3",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. This function is used to calculate the length of a string, but it does not check for null bytes (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte, or by manually adding a null byte at the end of your string after it has been populated.\n\nAdditionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read. This can prevent buffer overflows by ensuring that `strnlen()` does not read past the end of the string.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability in the provided code:\n\n```cpp\nsize_t len = strnlen(dev_type, MAX_DEV_TYPE_LEN);\nif (len >= MAX_DEV_TYPE_LEN) {\n    // Handle error: dev_type is not null-terminated\n} else {\n    if (io_utils_write_to_file(sys_dir_bus_new_dev, dev_type, len + 1) != 0) {\n        // Handle error: write failed\n    }\n}\n```\n\nIn this code, `MAX_DEV_TYPE_LEN` should be defined as the maximum expected length of `dev_type`.\n\n## Library Dependencies\n\nThe provided code does not specify any library dependencies. However, the `strlen()` function is part of the C standard library, so the code will need to include `<cstring>` or `<string.h>`.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-125",
                    "url": "https://cwe.mitre.org/data/definitions/125.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-125"
                ]
              }
            },
            {
              "id": "36b1fc48-134a-3c7a-a00d-0dd44f18ef1f",
              "name": "Detected Use of Prohibited C Function (strcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause memory corruption, leading to unpredictable program behavior, crashes, or even code execution. This is why the use of `strcpy` is often flagged as a vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter. This allows the function to ensure that it does not write past the end of the buffer. Functions like `strncpy`, `strlcpy` or `memcpy` can be used instead. However, these functions have their own caveats and must be used correctly.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c1024\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nThis code will copy the string \"24c1024\" into `ee->eeprom_type_name`, but it will not write past the end of `ee->eeprom_type_name`. The `- 1` and the subsequent line ensure that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "6f6c9861-c3e1-3193-87a2-33a5730f82e0",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. This function is used to calculate the length of a string, but it does not check for null bytes (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null byte, or by manually adding a null byte at the end of your string after it has been populated.\n\nAdditionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read. This can prevent buffer overflows by ensuring that `strnlen()` does not read past the end of the string.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability in the provided code:\n\n```cpp\nsize_t len = strnlen(dev_type, MAX_DEV_TYPE_LEN);\nif (len >= MAX_DEV_TYPE_LEN) {\n    // Handle error: dev_type is not null-terminated\n} else {\n    if (io_utils_write_to_file(sys_dir_bus_new_dev, dev_type, len + 1) != 0) {\n        // Handle error: write failed\n    }\n}\n```\n\nIn this code, `MAX_DEV_TYPE_LEN` should be defined as the maximum expected length of `dev_type`.\n\n## Library Dependencies\n\nThe provided code does not specify any library dependencies. However, the `strlen()` function is part of the C standard library, so the code will need to include `<cstring>` or `<string.h>`.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-125",
                    "url": "https://cwe.mitre.org/data/definitions/125.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-125"
                ]
              }
            },
            {
              "id": "79d499fa-b735-3499-94f5-8107762aa873",
              "name": "Detected Use of Prohibited C Function (strcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(ee->eeprom_type_name, \"24c256\")`, the function `strcpy` is used to copy the string \"24c256\" into the `eeprom_type_name` field of the `ee` object. If the size of `eeprom_type_name` is less than the size of the string \"24c256\", this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c256\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(ee->eeprom_type_name) - 1` characters from the source string to the destination buffer, and then manually null-terminate the destination string.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "79e5dd66-4c75-31b9-ab51-f1516be73d06",
              "name": "Detected Use of Prohibited C Function (strcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause memory corruption, leading to unpredictable program behavior, crashes, or even code execution.\n\nIn the provided code snippet, `strcpy(ee->eeprom_type_name, \"24c128\")`, the function `strcpy` is used to copy the string \"24c128\" into the `eeprom_type_name` field of the `ee` object. If the size of `eeprom_type_name` is less than the size of the string \"24c128\", it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c128\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` copies at most `sizeof(ee->eeprom_type_name) - 1` characters from the source string to the destination buffer. The last line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "5e9c6052-9828-3940-b653-373c1053f486",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause memory corruption, leading to unpredictable program behavior, crashes, or even code execution.\n\nIn the provided code snippet, `strcpy(ee->eeprom_type_name, \"24c64\")`, the string \"24c64\" is copied into `ee->eeprom_type_name` without checking if the destination buffer is large enough to hold the source string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter. This allows the function to know the size of the destination buffer and prevent buffer overflow. Functions like `strncpy`, `strlcpy` or `memcpy` can be used instead.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c64\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(ee->eeprom_type_name) - 1` ensures that the copied string will not exceed the size of the destination buffer. The last line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "f7cfb2af-5336-384a-b097-1ed1371dad23",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\nIn the provided code snippet, `strcpy(ee->eeprom_type_name, \"24c32\")`, the string \"24c32\" is being copied into `ee->eeprom_type_name` without any size checks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace `strcpy` with a safer function that includes a size parameter, such as `strncpy`. This function will only copy as many characters as the size parameter specifies, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c32\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(ee->eeprom_type_name) - 1` is used as the size parameter to leave room for the null terminator. The null terminator is then manually added to the end of the string.\n\n## Library Dependencies\n\nThe code snippet requires the `<cstring>` library for the `strcpy` and `strncpy` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-119"
                ]
              }
            },
            {
              "id": "d7a353a4-1ddd-3c02-bdc7-7099d00cd27d",
              "name": "Detected Use of Prohibited C Function (strcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, `strcpy(ee->eeprom_type_name, \"24c512\")`, the function `strcpy` is used to copy the string \"24c512\" into the `eeprom_type_name` field of the `ee` object. If the size of `eeprom_type_name` is less than the size of the string \"24c512\", this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `strncpy`:\n\n```cpp\nstrncpy(ee->eeprom_type_name, \"24c512\", sizeof(ee->eeprom_type_name) - 1);\nee->eeprom_type_name[sizeof(ee->eeprom_type_name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` copies at most `sizeof(ee->eeprom_type_name) - 1` characters from the source string to the destination buffer. The last line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            },
            {
              "id": "ee7aac1c-3ef8-3fbb-ba99-39b2a503a73c",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the absence of explicit checks for null pointers on either the source or destination. The destination buffer is accessed via a pointer, and there is no evidence of a guard ensuring it is not null before the memory copy operation. The source is not a pointer expression, so the risk is primarily with the destination. The function call is flagged as 'GENUINE', reinforcing the assessment. The probability of this being a false positive is further reduced because the destination may be null, which can lead to a crash or undefined behavior if not properly checked. There is no indication that the length argument is derived from the destination's capacity, and no guard is present to ensure safe operation. An explicit null-termination is present after the copy, but this does not mitigate the risk of a null destination pointer.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer (`info`) and its `product_vendor` member are not null. This prevents undefined behavior if the destination is accidentally null at runtime.\n\n```c\nif (info != NULL && info->product_vendor != NULL) {\n    memcpy(info->product_vendor, VENDOR_VSTR_POINT(&hat.vinf), hat.vinf.vslen);\n    // ...\n}\nelse {\n    // Handle error: destination is null\n}\n```\n\nThis check ensures that the destination buffer is valid before copying data into it, preventing crashes or memory corruption.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "a4833824-bcd1-3acc-88d7-57640bab30b1",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that the destination pointer may be null at the point of the memory copy operation. There are no explicit checks to ensure that the destination pointer is valid before performing the copy. The source is considered safe as it is not a pointer expression, but the destination pointer ('info') could be null, which would result in a crash or undefined behavior if the function is called with a null argument. The presence of a null-terminator assignment after the copy does not mitigate this risk. The absence of overlap between source and destination, and the fact that the source cannot be null, slightly reduce the risk, but the lack of a guard for the destination pointer is a significant concern.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the destination is null.\n\n```c\nif (info != NULL) {\n    memcpy(info->product_name, VENDOR_PSTR_POINT(&hat.vinf), hat.vinf.pslen);\n    info->product_name[hat.vinf.pslen] = '\\0';\n}\n```\n\nAlternatively, handle the error case as appropriate for your application, such as returning an error code or logging an error if the destination pointer is null.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-476"
                ]
              }
            },
            {
              "id": "940711d2-4ae3-3efc-876e-c9c96722c5de",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict confirms it as genuine. The code copies data from one buffer to another using a memory copy operation, but there are no explicit checks to ensure that either the source or destination pointers are not null before the operation. If either pointer is null, this will result in undefined behavior, potentially leading to a crash or security issue. The risk is further increased because the analysis detected that both the source and destination pointers may be null at this point in the code, and there are no guards or capacity checks in place.\n\n## In Context Remediation\nBefore performing the memory copy operation, add explicit checks to ensure that both the source and destination pointers are not null. This prevents undefined behavior if either pointer is invalid.\n\n```c\nif (dt_data != NULL && hat != NULL && hat->device_tree_buffer != NULL) {\n    memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size);\n} else {\n    // Handle error: one or more pointers are null\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-119",
                    "url": "https://cwe.mitre.org/data/definitions/119.html"
                  },
                  {
                    "id": "CWE-476",
                    "url": "https://cwe.mitre.org/data/definitions/476.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-119",
                  "CWE-476"
                ]
              }
            },
            {
              "id": "d86c7ef1-63b5-3922-a1fb-d6a2b86819ba",
              "name": "Detected Use of Prohibited C Function (strcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\".\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions prevent buffer overflow by not copying more characters than the destination buffer can hold.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function, which includes a size parameter:\n\n```cpp\nstrncpy(VENDOR_PSTR_POINT(vinf), hat->product_name, sizeof(VENDOR_PSTR_POINT(vinf)));\n```\n\nThis code will copy the string from `hat->product_name` to `VENDOR_PSTR_POINT(vinf)`, but not more than `sizeof(VENDOR_PSTR_POINT(vinf))` characters.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for the `strcpy` and `strncpy` functions.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  },
                  {
                    "id": "CWE-676",
                    "url": "https://cwe.mitre.org/data/definitions/676.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-120",
                  "CWE-676"
                ]
              }
            },
            {
              "id": "942b6323-8397-3908-860f-754520add96b",
              "name": "Problematic C function detected (memcpy)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code performs a memory copy operation without checking whether the source or destination pointers are null. If either pointer is null, this will result in undefined behavior, which can lead to program crashes or security vulnerabilities. The analysis indicates that there are no explicit checks to ensure that the source (atom_data) or the destination (hat or its members) are valid before the memcpy call. The risk is further increased because the function does not appear to have any guard conditions or null pointer checks prior to the operation. This is a common source of critical bugs in C code, especially when dealing with pointers and dynamic memory.\n\n## In Context Remediation\nBefore performing the memory copy, add explicit checks to ensure that both the source and destination pointers are not null. This prevents undefined behavior if either pointer is invalid.\n\n```c\nif (hat && hat->dt_data.dt_data && atom_data) {\n    memcpy(hat->dt_data.dt_data, atom_data, hat->dt_data.dt_data_size);\n} else {\n    // Handle error: one or more pointers are null\n}\n```\n\nThis approach ensures that the memory copy only occurs when all pointers are valid, reducing the risk of crashes or security issues.\n\n___\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "dd6f95d9-5670-3213-a08f-dd7fd6a23d8d",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen` is used to determine the length of `hat->product_name`. If `hat->product_name` is not null-terminated, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent reading past the end of a buffer.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and provide a maximum length to prevent buffer overflows:\n\n```cpp\n#include <string.h> // for strnlen\n\n// Define a maximum length for product_name\n#define MAX_PRODUCT_NAME_LENGTH 100\n\nvinf->pslen = strnlen(hat->product_name, MAX_PRODUCT_NAME_LENGTH);\n```\n\n## Library Dependencies\n\nThe code example requires the `string.h` library for the `strnlen` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "32c2184a-45bc-3b01-bd9f-ca59e3ecb75a",
              "name": "Detected Vulnerability in C Function (strlen)",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior. This is a common vulnerability in C and C++ programming.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen` such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nIn the given code snippet, the vulnerability can be fixed by checking if `hat->vendor_name` is null-terminated before passing it to `strlen`. If it's not, you should manually add a null character at the end of the string.\n\n```cpp\nif (hat->vendor_name != NULL) {\n    size_t len = strnlen(hat->vendor_name, MAX_LENGTH);\n    vinf->vslen = len;\n} else {\n    // handle error\n}\n```\n\nIn this code, `MAX_LENGTH` should be the maximum length that `hat->vendor_name` can have. This ensures that `strnlen` does not read beyond the intended memory even if `hat->vendor_name` is not null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-126",
                    "url": "https://cwe.mitre.org/data/definitions/126.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-126"
                ]
              }
            },
            {
              "id": "970828de-cdad-3b07-b070-0e3a3e81f988",
              "name": "\"Detected Use of Prohibited C Function (strcpy)\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the two strings, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination string.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial-of-service attacks, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include array bounds checking, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require the size of the destination string as an argument, which can prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function:\n\n```cpp\nstrncpy(VENDOR_VSTR_POINT(vinf), hat->vendor_name, sizeof(VENDOR_VSTR_POINT(vinf)));\n```\n\nThis code will copy the string from `hat->vendor_name` to `VENDOR_VSTR_POINT(vinf)`, but it will not copy more characters than the size of `VENDOR_VSTR_POINT(vinf)`, preventing a buffer overflow.\n\n## Library Dependencies\n\nThe `strcpy` and `strncpy` functions are part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-120",
                    "url": "https://cwe.mitre.org/data/definitions/120.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-120"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "e7f4cdb0-194b-3405-a75e-2419864dc261",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 13,
                  "endLine": 317,
                  "endColumn": 18,
                  "charOffset": 9788,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "93433fa55cba15b5cf99e3d7eb93200dcf48b27e912e159a2bd8a9cbe9ba0b68",
            "glog-pfp-ruleFileCode/v1": "0fbde2e187ed10c1aa7ecfe160383a61f96c01c98598bbe6fa6a8a5bac0f03a0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0fbde2e187ed10c1aa7ecfe160383a61f96c01c98598bbe6fa6a8a5bac0f03a0"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "be6b2f35-69ca-3f49-afe0-e7fd1fe6f12f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unintended time.sleep() function call vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 17,
                  "endLine": 300,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                time.sleep(0.1)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5e2d9ea2a742bafb179a24bfdb562d00e34df8eef277efcba356b6a9c9128212",
            "glog-pfp-ruleFileCode/v1": "4ba5d60b36a6af32e2b035cea0b65bd9a912a2c61742aa4ab5eca67a817d7f6a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4ba5d60b36a6af32e2b035cea0b65bd9a912a2c61742aa4ab5eca67a817d7f6a"
          },
          "properties": {}
        },
        {
          "ruleId": "d0fa257c-edeb-34b5-957b-b1b28f3517e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/rpi/rpi.c"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 6,
                  "endLine": 180,
                  "endColumn": 11,
                  "charOffset": 6779,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c48441718541b9e2be160103d89e28d220d8e6c6d15908b6b06fd4503a223df5",
            "glog-pfp-ruleFileCode/v1": "53a714637ebf7f8dcfcb49c29f70662c6c87e4caf3af4c5c7362b6443ab56165"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "53a714637ebf7f8dcfcb49c29f70662c6c87e4caf3af4c5c7362b6443ab56165"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24724d34-6f22-307d-b193-2d2a74626e13",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unintended time.sleep() function call vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 13,
                  "endLine": 236,
                  "endColumn": 28,
                  "snippet": {
                    "text": "            time.sleep(0.5)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "11f5b5a12967e22baa5047631de07feb81a49749a2c317f6ce4eec8e5b210ffb",
            "glog-pfp-ruleFileCode/v1": "500c48db9afa71025642253289a6046e095298ad855ef6eb55690438083d78f0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "500c48db9afa71025642253289a6046e095298ad855ef6eb55690438083d78f0"
          },
          "properties": {}
        },
        {
          "ruleId": "b9c142a0-59e6-3fc5-8591-ef43cf911bef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unintended time.sleep() function call vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/python/soapy_iq_cal.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 17,
                  "endLine": 275,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                time.sleep(1)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1c15a977c48afa34751be74f5df9cca6e20ef996d0361fddef087d30eb7c18f7",
            "glog-pfp-ruleFileCode/v1": "77c9594985fb67e2c3dffd2a532b717d58b08b8971c9f31fb689e4048ae026ca"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "77c9594985fb67e2c3dffd2a532b717d58b08b8971c9f31fb689e4048ae026ca"
          },
          "properties": {}
        },
        {
          "ruleId": "dbeafd82-8ae1-3c0e-a39b-a5799a536a4a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 61,
                  "endLine": 226,
                  "endColumn": 108,
                  "charOffset": 6909,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(&(T),gmtime(&time_now),sizeof(struct tm)",
                    "rendered": {
                      "text": "memcpy(&(T),gmtime(&time_now),sizeof(struct tm)",
                      "markdown": "`memcpy(&(T),gmtime(&time_now),sizeof(struct tm)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2f01b134ebec715e3bbd14f02edd996680d54d203b812abcd7864dd59ac7740f",
            "glog-pfp-ruleFileCode/v1": "b85d475d1f98cfffd8fc010dd1acaa79077d82c046daf2a8630a3423e10feee3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b85d475d1f98cfffd8fc010dd1acaa79077d82c046daf2a8630a3423e10feee3"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6909,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(T), <size of &(T)>, gmtime(&time_now), sizeof(struct tm)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a49ceeea-1ca7-3d5b-b986-b15ff75acc25",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 289,
                  "startColumn": 13,
                  "endLine": 289,
                  "endColumn": 18,
                  "charOffset": 9033,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2a97228f8becdfb521a9d007e70a52d01d5d553260b8d987297c11711d9680d3",
            "glog-pfp-ruleFileCode/v1": "cc5176a5c5fd7ef031bcd294a4c66a30c7f9a7cd03b166fac980398ee6a75ba1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cc5176a5c5fd7ef031bcd294a4c66a30c7f9a7cd03b166fac980398ee6a75ba1"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d543ac71-bf3f-3a7a-a3bd-b4c2610b5860",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Catastrophic Backtracking Vulnerability in Regex `r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)'` May Lead to Denial of Service Attacks"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 13,
                  "endLine": 33,
                  "endColumn": 74,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_HEADER_FILE\\(([^\\s]*)\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d4fb257e27fd881774a9734697438cb8721e178c602636b83d2bbab0dc032ae7",
            "glog-pfp-ruleFileCode/v1": "006b5b84cd767c80266e6c443bd3b6df57b1cca28532746246ecd86d33a03d70"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "006b5b84cd767c80266e6c443bd3b6df57b1cca28532746246ecd86d33a03d70"
          },
          "properties": {}
        },
        {
          "ruleId": "ac2ed76d-d3ed-3603-920d-eddc9c82ae48",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential vulnerability to catastrophic backtracking in Regex `r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)'` may result in denial of service attacks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 13,
                  "endLine": 15,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_GEN_AUTOMATIC\\(([^\\s])\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c72b26c26e00a50eca198753238873ae5c9fab6a25a4abdbeead8fae0bd3da2a",
            "glog-pfp-ruleFileCode/v1": "d1a3cc52c8c064447a3d156f520b45fe729d8c54b3b16a13bc351bc5e340b8ff"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d1a3cc52c8c064447a3d156f520b45fe729d8c54b3b16a13bc351bc5e340b8ff"
          },
          "properties": {}
        },
        {
          "ruleId": "981fbd69-fa76-3376-b3fc-78535df301e6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 2,
                  "endLine": 334,
                  "endColumn": 9,
                  "charOffset": 10335,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d86e394c64974bd3831306d702668b57471a64e18a63b14b6361dc570864814a",
            "glog-pfp-ruleFileCode/v1": "84300d56bfaded7cfeae1456c696ac663ff59205fb4a3d7f248bf92612521bc5"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "84300d56bfaded7cfeae1456c696ac663ff59205fb4a3d7f248bf92612521bc5"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "af134eba-b07e-3963-9583-68ad69166e70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 7,
                  "endLine": 95,
                  "endColumn": 33,
                  "charOffset": 2547,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(prod->git_pat_pass)",
                    "rendered": {
                      "text": "strlen(prod->git_pat_pass)",
                      "markdown": "`strlen(prod->git_pat_pass)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "19eb64b2f96c78e8009a317dcf83cf14241a76a833736cb65725ab267a917741",
            "glog-pfp-ruleFileCode/v1": "ed3ebbba8089ab5d43b4f9638f63cb876ea809c48c3f945fda496ec94dbe7ed7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ed3ebbba8089ab5d43b4f9638f63cb876ea809c48c3f945fda496ec94dbe7ed7"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2547,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(prod->git_pat_pass, <size of prod->git_pat_pass>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2547,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(prod->git_pat_pass, <size of prod->git_pat_pass>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ac5751c1-904e-3519-86a1-2459014be77c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unintended time.sleep() function call vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/python/usblcd.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 5,
                  "endLine": 30,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    sleep(1)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5927c04f64503721ada0c4cd02fb3e83ad5c771d02fa2afd62e623e3ccb97a45",
            "glog-pfp-ruleFileCode/v1": "84f1957fb22115bca0e3ce88dbe09d7d8775173fc914db7d80a60acfe41f763c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "84f1957fb22115bca0e3ce88dbe09d7d8775173fc914db7d80a60acfe41f763c"
          },
          "properties": {}
        },
        {
          "ruleId": "9acc7217-14a6-3e9a-846e-09d2333e2036",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 11,
                  "endLine": 82,
                  "endColumn": 37,
                  "charOffset": 2269,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(prod->git_pat_user)",
                    "rendered": {
                      "text": "strlen(prod->git_pat_user)",
                      "markdown": "`strlen(prod->git_pat_user)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c3c0fd526d705e0356452600924d25a024e0e5eeedb2a54a477739fec6ccecfe",
            "glog-pfp-ruleFileCode/v1": "ea0ca2ecca82354c3a854eb8687ef27e119cdffee957a5eca1cad9849dfbd181"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ea0ca2ecca82354c3a854eb8687ef27e119cdffee957a5eca1cad9849dfbd181"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2269,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(prod->git_pat_user, <size of prod->git_pat_user>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2269,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(prod->git_pat_user, <size of prod->git_pat_user>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "df4960bd-11d2-35c7-8600-d9136ef76147",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Denial of Service Vulnerability in Regex `r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)'` due to Catastrophic Backtracking"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 13,
                  "endLine": 24,
                  "endColumn": 74,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_USE_PYGCCXML\\(([^\\s])\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7be93dec7ff0f1c7460704b047f2263e088e3358d62f88acffd7f1d13ff96989",
            "glog-pfp-ruleFileCode/v1": "75592c458b3e7c33eb1dd949b3c911016bb16b2c835d654919ad1712b778ecea"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "75592c458b3e7c33eb1dd949b3c911016bb16b2c835d654919ad1712b778ecea"
          },
          "properties": {}
        },
        {
          "ruleId": "b5eff820-aaa1-3b44-9222-0389fb5b0274",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 1,
                  "endLine": 63,
                  "endColumn": 37,
                  "charOffset": 1824,
                  "charLength": 36,
                  "snippet": {
                    "text": "strcpy(prod->git_res_directory, dir)",
                    "rendered": {
                      "text": "strcpy(prod->git_res_directory, dir)",
                      "markdown": "`strcpy(prod->git_res_directory, dir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "23b0adba4386834fe5f4938400a8362ad2133af4225f930eafea99d6d291686d",
            "glog-pfp-ruleFileCode/v1": "89605b0231da81e480438ef3cdffeb3576e32302e63dfb7faf521af736be8d40"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "89605b0231da81e480438ef3cdffeb3576e32302e63dfb7faf521af736be8d40"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1824,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "strcpy_s(prod->git_res_directory, <size of prod->git_res_directory>,  dir)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1824,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "strlcpy(prod->git_res_directory,  dir, <size of prod->git_res_directory>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c65aaffe-3eed-3934-bd2a-cc08b84064ac",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 1,
                  "endLine": 62,
                  "endColumn": 29,
                  "charOffset": 1793,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(prod->git_repo, repo)",
                    "rendered": {
                      "text": "strcpy(prod->git_repo, repo)",
                      "markdown": "`strcpy(prod->git_repo, repo)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f74c723293263960f717d9118a8a4481cab0bede2837e4760d5490ec0cc01ebe",
            "glog-pfp-ruleFileCode/v1": "9f6c990d529cd3f8bfae21ac587de103e5383bb7006d23f5bbfe6b49803f22d1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9f6c990d529cd3f8bfae21ac587de103e5383bb7006d23f5bbfe6b49803f22d1"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1793,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(prod->git_repo, <size of prod->git_repo>,  repo)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1793,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(prod->git_repo,  repo, <size of prod->git_repo>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fb6898e6-6a4c-3462-a7a1-03216b7e647c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 28,
                  "endLine": 148,
                  "endColumn": 49,
                  "charOffset": 4322,
                  "charLength": 21,
                  "snippet": {
                    "text": "strlen(commit_string)",
                    "rendered": {
                      "text": "strlen(commit_string)",
                      "markdown": "`strlen(commit_string)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0216bd586affd6279c040675125a3810dcd025056fc1335d25c00157c91df1e2",
            "glog-pfp-ruleFileCode/v1": "0291287e7e7ffe06b0291724ef1a60198e7f6d13ed2780584a6a2be0a01ef0be"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0291287e7e7ffe06b0291724ef1a60198e7f6d13ed2780584a6a2be0a01ef0be"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4322,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strlen_s(commit_string, <size of commit_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4322,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strnlen(commit_string, <size of commit_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0f0db57a-28a9-3ff3-a514-977b00727cd9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential for catastrophic backtracking vulnerability in Regex `r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)'` leading to denial of service attacks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/gr-caribouLite/python/caribouLite/bindings/header_utils.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 13,
                  "endLine": 42,
                  "endColumn": 79,
                  "snippet": {
                    "text": "        m = re.search(r'BINDTOOL_HEADER_FILE_HASH\\(([^\\s]*)\\)', self.file_txt)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b2e6c863be98136034599542c512651073768aeaa94aeeb90b540900de6c71ba",
            "glog-pfp-ruleFileCode/v1": "a47c1032e4d1198c182e2b7b24b1c11566f78604748d8ccaed7aac6a8fb5ebd0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a47c1032e4d1198c182e2b7b24b1c11566f78604748d8ccaed7aac6a8fb5ebd0"
          },
          "properties": {}
        },
        {
          "ruleId": "981064e6-83cc-3df1-8c8a-c3a9673d5957",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 7,
                  "endLine": 69,
                  "endColumn": 12,
                  "charOffset": 1983,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "09f8f615d7ce4d318967ee640f658ed03b8b9b276bff4e00b2d96262a9533dab",
            "glog-pfp-ruleFileCode/v1": "8518dec808799b6abfe293e73ffb7b8d4afc0ccdef31d16e2287665528692176"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8518dec808799b6abfe293e73ffb7b8d4afc0ccdef31d16e2287665528692176"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "65369937-efb7-34e6-8a5a-eb20ac25cc8f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unintended time.sleep() function call vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/python/testlcd.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 5,
                  "endLine": 116,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    time.sleep(2.0)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "89b93f0722b0b23030c660a81c21b855f24ab07a0a457255790394e6235f4939",
            "glog-pfp-ruleFileCode/v1": "25f20a160f27419b4308748ccb2d51b8baa29eb535e2d57cebacdfa388d0f583"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "25f20a160f27419b4308748ccb2d51b8baa29eb535e2d57cebacdfa388d0f583"
          },
          "properties": {}
        },
        {
          "ruleId": "9036fca4-3351-3090-8910-71b1b5b1bcd4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/lcd.c"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 32,
                  "endLine": 145,
                  "endColumn": 43,
                  "charOffset": 3422,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(msg)",
                    "rendered": {
                      "text": "strlen(msg)",
                      "markdown": "`strlen(msg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a2913a6a29e74ae0a3d855540b12bd984d59d8cc0505461ad7c5bd54c18e7b21",
            "glog-pfp-ruleFileCode/v1": "0cdc5b6b444ddb7f6a15c451f8b03f35a4c0aec21b6d4b6406eae42dc1a1cc21"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0cdc5b6b444ddb7f6a15c451f8b03f35a4c0aec21b6d4b6406eae42dc1a1cc21"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3422,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3422,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c5406586-cb50-3e87-9f77-f54888437b3a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/lcd.c"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 32,
                  "endLine": 190,
                  "endColumn": 43,
                  "charOffset": 4394,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(msg)",
                    "rendered": {
                      "text": "strlen(msg)",
                      "markdown": "`strlen(msg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9f6b0ad707ba99428d9832bf60e54b675924cc2be41f553cd61cfae62f69e9cd",
            "glog-pfp-ruleFileCode/v1": "cacd15776456454cd61e6bdacf54c27eb25e0d4c6ff67b00abe4a1e334780000"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cacd15776456454cd61e6bdacf54c27eb25e0d4c6ff67b00abe4a1e334780000"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4394,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4394,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6661d5c7-64d0-3ffd-9242-a975069705b0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/lcd.c"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 32,
                  "endLine": 151,
                  "endColumn": 43,
                  "charOffset": 3601,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(msg)",
                    "rendered": {
                      "text": "strlen(msg)",
                      "markdown": "`strlen(msg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d171a14cd0ba83c780ec070db09b67b89f8fb8647f7917d6da72c27c96da0159",
            "glog-pfp-ruleFileCode/v1": "9320a65f0d03bf62dfdacce77b8506f5125928bbc322d90fc885a38cb9ca841b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9320a65f0d03bf62dfdacce77b8506f5125928bbc322d90fc885a38cb9ca841b"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3601,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3601,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c6c388e1-3736-34a9-bdf4-df6e289fa46c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 1,
                  "endLine": 61,
                  "endColumn": 32,
                  "charOffset": 1759,
                  "charLength": 31,
                  "snippet": {
                    "text": "strcpy(prod->git_pat_path, pat)",
                    "rendered": {
                      "text": "strcpy(prod->git_pat_path, pat)",
                      "markdown": "`strcpy(prod->git_pat_path, pat)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "32ca7d0f08402218e840f29810f195bd19d4b62eb00145f0bfb6ecc300d141d0",
            "glog-pfp-ruleFileCode/v1": "2480c86f069c4036110f45fa3f1568f6f5f4175fe7b4d90c8bf4871e6a7733be"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2480c86f069c4036110f45fa3f1568f6f5f4175fe7b4d90c8bf4871e6a7733be"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1759,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "strcpy_s(prod->git_pat_path, <size of prod->git_pat_path>,  pat)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/production_testing.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1759,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "strlcpy(prod->git_pat_path,  pat, <size of prod->git_pat_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "29f3f252-d886-378b-b8f3-d7828f439ae4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 15,
                  "endLine": 330,
                  "endColumn": 20,
                  "charOffset": 10066,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "14883e50b9ce01b3ac6d1f328ac7edb935ac6e1dde283dda98cc24b542dc21da",
            "glog-pfp-ruleFileCode/v1": "cbe2097c284a8040e323bf3bece95b3d0d33ce2a38956ffc735f5b653b82e82a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cbe2097c284a8040e323bf3bece95b3d0d33ce2a38956ffc735f5b653b82e82a"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aa305e1b-337b-3449-9622-b45ccc723d04",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 27,
                  "endLine": 211,
                  "endColumn": 31,
                  "charOffset": 6483,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2153c32f3be853a3d4ac9106712c767ffc37fb6fecc02dac108bec9bce4fa2ba",
            "glog-pfp-ruleFileCode/v1": "3ef9214b1e9774aba75b6ca6e03ce9a8d5109446818d50dc5953cddea3240e50"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3ef9214b1e9774aba75b6ca6e03ce9a8d5109446818d50dc5953cddea3240e50"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b59de62f-3e57-3ac6-a6ad-a1814c69eb25",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/lcd.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 32,
                  "endLine": 128,
                  "endColumn": 43,
                  "charOffset": 3049,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(msg)",
                    "rendered": {
                      "text": "strlen(msg)",
                      "markdown": "`strlen(msg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ffc58a54ca7c62ac34f5b86e85572312955b5ab62944bd56e63bd33584e9684e",
            "glog-pfp-ruleFileCode/v1": "cd7eac3a05dc8abb0949d7669e0d308d11300126bc94cfbeb62b1a2d9b11a9d9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cd7eac3a05dc8abb0949d7669e0d308d11300126bc94cfbeb62b1a2d9b11a9d9"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3049,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/production_utils/lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3049,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(msg, <size of msg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "928edd49-be3e-3221-ba1e-a4e4157729d3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/production_utils/lcd.c"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 37,
                  "endLine": 75,
                  "endColumn": 46,
                  "charOffset": 1777,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f800efea8cbe82ab652fcecf41ce07c4559f6cc254850dd9dabe2edc4a272875",
            "glog-pfp-ruleFileCode/v1": "1515014bf2ab3775b4adebd341f9024a27da1251590f0407eced0a68b4b5653e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1515014bf2ab3775b4adebd341f9024a27da1251590f0407eced0a68b4b5653e"
          },
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "26244ae6-7a84-352e-996f-4a11db4473b1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 21,
                  "endLine": 207,
                  "endColumn": 25,
                  "charOffset": 6356,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "739f6138b8022634fe2fc0d38b69e5e57f80faf0db975ccf907ac3e0f97802d2",
            "glog-pfp-ruleFileCode/v1": "7834168d226ec209aa2cbeb1f37459910dbe79d2b25d55692aa7cc48c2e63d45"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7834168d226ec209aa2cbeb1f37459910dbe79d2b25d55692aa7cc48c2e63d45"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "53386e6f-2dd7-3ade-bb10-d9e9e94768b5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 22,
                  "endLine": 196,
                  "endColumn": 26,
                  "charOffset": 6078,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b63e3b2b23859d0467bf4feef976ca74d570f99822ac8d5317313fbb2b89f41e",
            "glog-pfp-ruleFileCode/v1": "78aa24e7f1928055160fba7a80144c366e8a34792fababa2b6c4a822ce8bf65f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "78aa24e7f1928055160fba7a80144c366e8a34792fababa2b6c4a822ce8bf65f"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c7243d19-dadc-3f85-a168-ef29f12f99c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_radio.c"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 1,
                  "endLine": 126,
                  "endColumn": 35,
                  "charOffset": 4725,
                  "charLength": 143,
                  "snippet": {
                    "text": "memcpy (&radio->interrupts, \n\t\t\t(radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24),\n\t\t\tsizeof(cariboulite_radio_irq_st)",
                    "rendered": {
                      "text": "memcpy (&radio->interrupts, \n\t\t\t(radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24),\n\t\t\tsizeof(cariboulite_radio_irq_st)",
                      "markdown": "`memcpy (&radio->interrupts, \n\t\t\t(radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24),\n\t\t\tsizeof(cariboulite_radio_irq_st)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "13df64b80688a29cc5ee86abee68969ae13d6062a45cefb24ddc44c13ee6d3a9",
            "glog-pfp-ruleFileCode/v1": "51fdca2d703409b986cb5a4c84618f9a2edd21047b6a94c6df9239ef16c8a191"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "51fdca2d703409b986cb5a4c84618f9a2edd21047b6a94c6df9239ef16c8a191"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/cariboulite_radio.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4725,
                        "charLength": 143
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&radio->interrupts, <size of &radio->interrupts>,  \n\t\t\t(radio->type == cariboulite_channel_s1g) ? (&irq.radio09) : (&irq.radio24), \n\t\t\tsizeof(cariboulite_radio_irq_st)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "20cef17f-0569-36b0-a7ae-5d6b891d1432",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 192,
                  "startColumn": 21,
                  "endLine": 192,
                  "endColumn": 25,
                  "charOffset": 5953,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "224625a51597dddc92a15e38734edbe7932c7f01989a26222de8c764f7675ed3",
            "glog-pfp-ruleFileCode/v1": "e9b7e290c913a6653efd1686f5957d0f6acd2968be46f02a8b7f4e98f6baa988"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "e9b7e290c913a6653efd1686f5957d0f6acd2968be46f02a8b7f4e98f6baa988"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "31d466ee-d714-3a5a-9532-9983758b5bd7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_util.c"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 27,
                  "endLine": 188,
                  "endColumn": 31,
                  "charOffset": 5832,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b87e60cbb5d269c42d5a344ac34d9d620153618b53451028ad0178362d77f84d",
            "glog-pfp-ruleFileCode/v1": "786263b52b6eba4997d1b68bbd76869cd91265b436b4fd473f9bb1db66298930"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "786263b52b6eba4997d1b68bbd76869cd91265b436b4fd473f9bb1db66298930"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cf929797-df48-3d64-a5b2-28376ddbf33c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                },
                "region": {
                  "startLine": 953,
                  "startColumn": 1,
                  "endLine": 953,
                  "endColumn": 18,
                  "charOffset": 31824,
                  "charLength": 17,
                  "snippet": {
                    "text": "memcpy(p, s_p, n)",
                    "rendered": {
                      "text": "memcpy(p, s_p, n)",
                      "markdown": "`memcpy(p, s_p, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ed838bedeaa4de344ffec2a56bfd334a459dae7383f1e44e5d9b554e301e763f",
            "glog-pfp-ruleFileCode/v1": "ced05eb5a0a074276d0bbc8e7b8b9c83d6b545e20770e70b7871e76b1a1c4f82"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ced05eb5a0a074276d0bbc8e7b8b9c83d6b545e20770e70b7871e76b1a1c4f82"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31824,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "memcpy_s(p, <size of p>,  s_p,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ddb6b915-3c3d-3f07-943a-d6566642738f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/CaribouLiteRadioCpp.cpp"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 8,
                  "endLine": 126,
                  "endColumn": 45,
                  "charOffset": 4480,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(meta, _read_metadata, (size_t)",
                    "rendered": {
                      "text": "memcpy(meta, _read_metadata, (size_t)",
                      "markdown": "`memcpy(meta, _read_metadata, (size_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cf54d935d4763fcf5515c4da477dab2136d9cdbc40cdb4585f4b223c23af4424",
            "glog-pfp-ruleFileCode/v1": "7b37f194f34c07c188fd94c38bfde435f91029c0e95e31c4a132332e2101e97e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b37f194f34c07c188fd94c38bfde435f91029c0e95e31c4a132332e2101e97e"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/CaribouLiteRadioCpp.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4480,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(meta, <size of meta>,  _read_metadata,  (size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "14982622-55fb-3813-9644-5bfc097eab48",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 6,
                  "endLine": 175,
                  "endColumn": 38,
                  "charOffset": 6867,
                  "charLength": 32,
                  "snippet": {
                    "text": "strcpy(info->revision, revision)",
                    "rendered": {
                      "text": "strcpy(info->revision, revision)",
                      "markdown": "`strcpy(info->revision, revision)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "047f39f5ffc0f40b7c841362f8171e6f681c246170941a61ad1bb42312e11063",
            "glog-pfp-ruleFileCode/v1": "72b963e959ed0447537f7fb6a7e85f0929443badbf277fa8066c94fbfa0db314"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72b963e959ed0447537f7fb6a7e85f0929443badbf277fa8066c94fbfa0db314"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6867,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strcpy_s(info->revision, <size of info->revision>,  revision)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6867,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlcpy(info->revision,  revision, <size of info->revision>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "86f2987b-bc22-31e8-9d65-bdebd57877de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/cariboulite_setup.c"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 14,
                  "endLine": 663,
                  "endColumn": 70,
                  "charOffset": 24846,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(info, &sys->board_info, sizeof(hat_board_info_st)",
                    "rendered": {
                      "text": "memcpy(info, &sys->board_info, sizeof(hat_board_info_st)",
                      "markdown": "`memcpy(info, &sys->board_info, sizeof(hat_board_info_st)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "68dc78fab1c5771024f074327acf7270e0c2c304c92190d6a77767ba00ba97ff",
            "glog-pfp-ruleFileCode/v1": "338a5a4885c3f0c490eb68a6bbe75000525c47371dcb75fd52b0662873ccd0ef"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "338a5a4885c3f0c490eb68a6bbe75000525c47371dcb75fd52b0662873ccd0ef"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/cariboulite_setup.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24846,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(info, <size of info>,  &sys->board_info,  sizeof(hat_board_info_st)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0a608345-3c7e-3587-87e5-5f378174394c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 14,
                  "endLine": 108,
                  "endColumn": 30,
                  "charOffset": 3507,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(revision)",
                    "rendered": {
                      "text": "strlen(revision)",
                      "markdown": "`strlen(revision)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "91d36db62d49d93624cb7d606278e69532af54d919341753c5d0b9ae0fbda0f2",
            "glog-pfp-ruleFileCode/v1": "0f86510d77080f5b268c216144fd4b92c0882468a7ca5f1ab9a64d2dfd016099"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0f86510d77080f5b268c216144fd4b92c0882468a7ca5f1ab9a64d2dfd016099"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3507,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(revision, <size of revision>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3507,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(revision, <size of revision>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dcb67dee-15a9-3a7d-b3dc-0958b6b0c59d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                },
                "region": {
                  "startLine": 655,
                  "startColumn": 1,
                  "endLine": 655,
                  "endColumn": 36,
                  "charOffset": 24048,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(msg->p, ZF_LOG_EOL, eol_len)",
                    "rendered": {
                      "text": "memcpy(msg->p, ZF_LOG_EOL, eol_len)",
                      "markdown": "`memcpy(msg->p, ZF_LOG_EOL, eol_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2534be4f97510b09717f0955c688050eb3fbce5f3780d99b55bb08efbcb3d582",
            "glog-pfp-ruleFileCode/v1": "06b8680e5c87c67540188785cb4f2e4b80a000cba22e49473151cfaff2334986"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "06b8680e5c87c67540188785cb4f2e4b80a000cba22e49473151cfaff2334986"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/zf_log/zf_log.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24048,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(msg->p, <size of msg->p>,  ZF_LOG_EOL,  eol_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fe99c9e3-bc1a-381d-9347-73a78828a825",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 6,
                  "endLine": 114,
                  "endColumn": 38,
                  "charOffset": 3688,
                  "charLength": 32,
                  "snippet": {
                    "text": "strcpy(info->revision, revision)",
                    "rendered": {
                      "text": "strcpy(info->revision, revision)",
                      "markdown": "`strcpy(info->revision, revision)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4e091b0db326834651f92096106c8a0d0046b478d1383579601678f6f644ff59",
            "glog-pfp-ruleFileCode/v1": "8c000bf044503a4b28b5efc023e0479c649e83e73ad588ec0c25e45f9701a918"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8c000bf044503a4b28b5efc023e0479c649e83e73ad588ec0c25e45f9701a918"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3688,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strcpy_s(info->revision, <size of info->revision>,  revision)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3688,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlcpy(info->revision,  revision, <size of info->revision>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "48e6f013-60b9-3a3b-ae5d-3181fa968681",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 13,
                  "endLine": 77,
                  "endColumn": 18,
                  "charOffset": 2620,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "97b5639e8a0231e0c36612ea0786ee73e768f790c5a07be359d1cf248247f6e6",
            "glog-pfp-ruleFileCode/v1": "e9fb4b92ce248386ef287051b0e503ac4bd78aefe230641afec02302b821b279"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "e9fb4b92ce248386ef287051b0e503ac4bd78aefe230641afec02302b821b279"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "97f4f93a-c0de-3922-afad-3ab219c9913c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/io_utils/io_utils_sys_info.c"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 18,
                  "endLine": 87,
                  "endColumn": 23,
                  "charOffset": 2879,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0e89754cf6b4fda1ddf60b59e35db8008910f1a18e896cb7c6023b9e23e840d5",
            "glog-pfp-ruleFileCode/v1": "2b53302fc17f9908e65aa5121f0c8b679e2a775178638bdc39ff588190931020"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2b53302fc17f9908e65aa5121f0c8b679e2a775178638bdc39ff588190931020"
          },
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "121f44f2-49dc-3c56-8d37-83dd08c35f4f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 60,
                  "endLine": 129,
                  "endColumn": 76,
                  "charOffset": 3955,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(dev_type)",
                    "rendered": {
                      "text": "strlen(dev_type)",
                      "markdown": "`strlen(dev_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "edb77efe2013e5b0544d748fb2f00554adc641f7f6cf1d210049fd4de6ecc229",
            "glog-pfp-ruleFileCode/v1": "bc86859442b5b3d4731a841597387f4ab6ebc51885cbaa6ef7fb213678a35058"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bc86859442b5b3d4731a841597387f4ab6ebc51885cbaa6ef7fb213678a35058"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3955,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3955,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7fe84cfc-fffa-3c24-9365-83d84bcd12c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 61,
                  "endLine": 85,
                  "endColumn": 77,
                  "charOffset": 2696,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(dev_type)",
                    "rendered": {
                      "text": "strlen(dev_type)",
                      "markdown": "`strlen(dev_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b0d60c25dca15d131e54eb207c7c69a56604794c21683a8e26c1d97a68889866",
            "glog-pfp-ruleFileCode/v1": "7e0e80e1d4cf0f23d1f4c34a6a033ccaec429598e18b77427ba3ae11524f3356"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7e0e80e1d4cf0f23d1f4c34a6a033ccaec429598e18b77427ba3ae11524f3356"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2696,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2696,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "36b1fc48-134a-3c7a-a00d-0dd44f18ef1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 28,
                  "endLine": 29,
                  "endColumn": 67,
                  "charOffset": 988,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c1024\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c1024\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c1024\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ffd7c2e894906b2f500a41cfee444480a66e2cb6f4be5751fb5797884fd25de2",
            "glog-pfp-ruleFileCode/v1": "47a67a248eedaa889e8b5811224d4d0869bb2629f5fc1e589706f2ee8d4e847e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "47a67a248eedaa889e8b5811224d4d0869bb2629f5fc1e589706f2ee8d4e847e"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 988,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c1024\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 988,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c1024\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f6c9861-c3e1-3193-87a2-33a5730f82e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 61,
                  "endLine": 81,
                  "endColumn": 77,
                  "charOffset": 2522,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(dev_type)",
                    "rendered": {
                      "text": "strlen(dev_type)",
                      "markdown": "`strlen(dev_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d2609e21b6011319607c2bf01fc6c75b324489de47b5c2c0572c48b075cfd463",
            "glog-pfp-ruleFileCode/v1": "2804bfc9085788dc8cc466738714819d28190c29ac2c1acf2c169d1187921efb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2804bfc9085788dc8cc466738714819d28190c29ac2c1acf2c169d1187921efb"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2522,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2522,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(dev_type, <size of dev_type>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "79d499fa-b735-3499-94f5-8107762aa873",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 27,
                  "endLine": 27,
                  "endColumn": 65,
                  "charOffset": 789,
                  "charLength": 38,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c256\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c256\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c256\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bdb89f40d3a80d94fdadfff3917616e13720bd232308ea0931d5fc0cc82d1817",
            "glog-pfp-ruleFileCode/v1": "650b11bda70f6b9c32c694ea75550b50c4fc7c8813efc4dbfedf2d2ee64e873c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "650b11bda70f6b9c32c694ea75550b50c4fc7c8813efc4dbfedf2d2ee64e873c"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 789,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c256\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 789,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c256\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "79e5dd66-4c75-31b9-ab51-f1516be73d06",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 27,
                  "endLine": 26,
                  "endColumn": 65,
                  "charOffset": 690,
                  "charLength": 38,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c128\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c128\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c128\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "972dfbd86e0d958d981b8b8fae8193344bea2fc43596424b99e9ac33faf5c9fd",
            "glog-pfp-ruleFileCode/v1": "8cc044a5bf8e9891cd041e947dd5e01a2f7bc38765d9344d4e510b0aa789bee9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8cc044a5bf8e9891cd041e947dd5e01a2f7bc38765d9344d4e510b0aa789bee9"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 690,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c128\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 690,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c128\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5e9c6052-9828-3940-b653-373c1053f486",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 26,
                  "endLine": 25,
                  "endColumn": 63,
                  "charOffset": 593,
                  "charLength": 37,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c64\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c64\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c64\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "83bd1954e8e079cbc6a0b252e6fbf05596f875f1fe05a6c04044b00720db84b4",
            "glog-pfp-ruleFileCode/v1": "09066360b0e2036a3a4faaa51a376696c2874a2049b17e6bfeca07a1cfd45c9a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "09066360b0e2036a3a4faaa51a376696c2874a2049b17e6bfeca07a1cfd45c9a"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 593,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c64\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 593,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c64\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f7cfb2af-5336-384a-b097-1ed1371dad23",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 11,
                  "endLine": 31,
                  "endColumn": 48,
                  "charOffset": 1099,
                  "charLength": 37,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c32\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c32\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c32\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "945423f8149e5ebecfe7e394814cad2961d111f10fc8b169eb9dc62cc3d6bf87",
            "glog-pfp-ruleFileCode/v1": "94ae8ecda718ed1ae765a31b3a59091f68cb28bdf498d4f90a1e84e570e65480"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "94ae8ecda718ed1ae765a31b3a59091f68cb28bdf498d4f90a1e84e570e65480"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1099,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c32\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1099,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c32\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d7a353a4-1ddd-3c02-bdc7-7099d00cd27d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 27,
                  "endLine": 28,
                  "endColumn": 65,
                  "charOffset": 888,
                  "charLength": 38,
                  "snippet": {
                    "text": "strcpy(ee->eeprom_type_name, \"24c512\")",
                    "rendered": {
                      "text": "strcpy(ee->eeprom_type_name, \"24c512\")",
                      "markdown": "`strcpy(ee->eeprom_type_name, \"24c512\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "81593cf85fa49c5778af780b678a14e6ee4e8e8130db29173c8b024016532a52",
            "glog-pfp-ruleFileCode/v1": "7b32fb301ac2a85bb376f34a2ea256c550ba22adb0a44b8f64b1614c608f6a89"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b32fb301ac2a85bb376f34a2ea256c550ba22adb0a44b8f64b1614c608f6a89"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 888,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ee->eeprom_type_name, <size of ee->eeprom_type_name>,  \"24c512\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/eeprom_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 888,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strlcpy(ee->eeprom_type_name,  \"24c512\", <size of ee->eeprom_type_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ee7aac1c-3ef8-3fbb-ba99-39b2a503a73c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 681,
                  "startColumn": 1,
                  "endLine": 681,
                  "endColumn": 75,
                  "charOffset": 19925,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(info->product_vendor, VENDOR_VSTR_POINT(&hat.vinf), hat.vinf.vslen)",
                    "rendered": {
                      "text": "memcpy(info->product_vendor, VENDOR_VSTR_POINT(&hat.vinf), hat.vinf.vslen)",
                      "markdown": "`memcpy(info->product_vendor, VENDOR_VSTR_POINT(&hat.vinf), hat.vinf.vslen)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ec88f468a792a802a12e90d162dc41b4048eb5b8f90a83dd6d614233f2763bc8",
            "glog-pfp-ruleFileCode/v1": "dda4d19b7393ccb5c28ed67185145ae785d2ac191de55b00799e3340beaa413f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "dda4d19b7393ccb5c28ed67185145ae785d2ac191de55b00799e3340beaa413f"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19925,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(info->product_vendor, <size of info->product_vendor>,  VENDOR_VSTR_POINT(&hat.vinf),  hat.vinf.vslen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a4833824-bcd1-3acc-88d7-57640bab30b1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 677,
                  "startColumn": 1,
                  "endLine": 677,
                  "endColumn": 73,
                  "charOffset": 19707,
                  "charLength": 72,
                  "snippet": {
                    "text": "memcpy(info->product_name, VENDOR_PSTR_POINT(&hat.vinf), hat.vinf.pslen)",
                    "rendered": {
                      "text": "memcpy(info->product_name, VENDOR_PSTR_POINT(&hat.vinf), hat.vinf.pslen)",
                      "markdown": "`memcpy(info->product_name, VENDOR_PSTR_POINT(&hat.vinf), hat.vinf.pslen)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "94c1adb68e14d139148667180aa17a835c20d554b6251779a2a681b77dfe45b2",
            "glog-pfp-ruleFileCode/v1": "ea9fc7d22df09e4cb9613e838c7311bb34320e277372d77504cdf53080ae4d5f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ea9fc7d22df09e4cb9613e838c7311bb34320e277372d77504cdf53080ae4d5f"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19707,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "memcpy_s(info->product_name, <size of info->product_name>,  VENDOR_PSTR_POINT(&hat.vinf),  hat.vinf.pslen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "940711d2-4ae3-3efc-876e-c9c96722c5de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 486,
                  "startColumn": 1,
                  "endLine": 486,
                  "endColumn": 71,
                  "charOffset": 14357,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)",
                    "rendered": {
                      "text": "memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)",
                      "markdown": "`memcpy(dt_data, hat->device_tree_buffer, hat->device_tree_buffer_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6be5fca8df9768050088918170198bd29264b27b2f0efe851c304bf743493ae4",
            "glog-pfp-ruleFileCode/v1": "4c444ff2a1e3f0796c29d2de3897a65c5523c7af7bddc8a5b699648214b2887b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4c444ff2a1e3f0796c29d2de3897a65c5523c7af7bddc8a5b699648214b2887b"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14357,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dt_data, <size of dt_data>,  hat->device_tree_buffer,  hat->device_tree_buffer_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d86c7ef1-63b5-3922-a1fb-d6a2b86819ba",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 1,
                  "endLine": 387,
                  "endColumn": 51,
                  "charOffset": 10363,
                  "charLength": 50,
                  "snippet": {
                    "text": "strcpy(VENDOR_PSTR_POINT(vinf), hat->product_name)",
                    "rendered": {
                      "text": "strcpy(VENDOR_PSTR_POINT(vinf), hat->product_name)",
                      "markdown": "`strcpy(VENDOR_PSTR_POINT(vinf), hat->product_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "eb83e0488d333424d70bf87b02f412dbbe7a32fd858d88d7c53b0f68ac8a470d",
            "glog-pfp-ruleFileCode/v1": "2d36a41375aff8defcbfc16973a3bc8ee9c16211132068118fda845f364b86d1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2d36a41375aff8defcbfc16973a3bc8ee9c16211132068118fda845f364b86d1"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10363,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(VENDOR_PSTR_POINT(vinf), <size of VENDOR_PSTR_POINT(vinf)>,  hat->product_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10363,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(VENDOR_PSTR_POINT(vinf),  hat->product_name, <size of VENDOR_PSTR_POINT(vinf)>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "942b6323-8397-3908-860f-754520add96b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 346,
                  "startColumn": 5,
                  "endLine": 346,
                  "endColumn": 71,
                  "charOffset": 9171,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(hat->dt_data.dt_data, atom_data, hat->dt_data.dt_data_size)",
                    "rendered": {
                      "text": "memcpy(hat->dt_data.dt_data, atom_data, hat->dt_data.dt_data_size)",
                      "markdown": "`memcpy(hat->dt_data.dt_data, atom_data, hat->dt_data.dt_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9c81f042cc21bedbf318c89a6efadf5d062912c74f1d4126b84cadd3bfdbbb15",
            "glog-pfp-ruleFileCode/v1": "d25a0e2fe8e1c7c3c96ef757aa54745503a8a846753bdecac05f9b6fec8aaccf"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d25a0e2fe8e1c7c3c96ef757aa54745503a8a846753bdecac05f9b6fec8aaccf"
          },
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9171,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hat->dt_data.dt_data, <size of hat->dt_data.dt_data>,  atom_data,  hat->dt_data.dt_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dd6f95d9-5670-3213-a08f-dd7fd6a23d8d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 15,
                  "endLine": 385,
                  "endColumn": 40,
                  "charOffset": 10283,
                  "charLength": 25,
                  "snippet": {
                    "text": "strlen(hat->product_name)",
                    "rendered": {
                      "text": "strlen(hat->product_name)",
                      "markdown": "`strlen(hat->product_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "52ffe3ef5c4b528b6d1fb828d86fbf161c690f053fd8bf2a7222259e1d182d75",
            "glog-pfp-ruleFileCode/v1": "2418203f4c39d13132f30f6abbabe8a52b629751fe4d1429cda6201820e92456"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2418203f4c39d13132f30f6abbabe8a52b629751fe4d1429cda6201820e92456"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10283,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlen_s(hat->product_name, <size of hat->product_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10283,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strnlen(hat->product_name, <size of hat->product_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "32c2184a-45bc-3b01-bd9f-ca59e3ecb75a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 15,
                  "endLine": 384,
                  "endColumn": 39,
                  "charOffset": 10242,
                  "charLength": 24,
                  "snippet": {
                    "text": "strlen(hat->vendor_name)",
                    "rendered": {
                      "text": "strlen(hat->vendor_name)",
                      "markdown": "`strlen(hat->vendor_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2edfd3112e7650abc4a593c0f865ed285b37b79f1379c986c246bc8376b81645",
            "glog-pfp-ruleFileCode/v1": "a787275c8351f8507a13792f47fb6ad22cc8e223f638b7b3d31bf279b2a82beb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a787275c8351f8507a13792f47fb6ad22cc8e223f638b7b3d31bf279b2a82beb"
          },
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10242,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strlen_s(hat->vendor_name, <size of hat->vendor_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10242,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strnlen(hat->vendor_name, <size of hat->vendor_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "970828de-cdad-3b07-b070-0e3a3e81f988",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "software/libcariboulite/src/hat/hat.c"
                },
                "region": {
                  "startLine": 386,
                  "startColumn": 1,
                  "endLine": 386,
                  "endColumn": 50,
                  "charOffset": 10311,
                  "charLength": 49,
                  "snippet": {
                    "text": "strcpy(VENDOR_VSTR_POINT(vinf), hat->vendor_name)",
                    "rendered": {
                      "text": "strcpy(VENDOR_VSTR_POINT(vinf), hat->vendor_name)",
                      "markdown": "`strcpy(VENDOR_VSTR_POINT(vinf), hat->vendor_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "26e7551515c9f4d8654179ddf6d1703a1cd0f80f0cf27c0454ea976f385c4bdb",
            "glog-pfp-ruleFileCode/v1": "acab9f043096295e34f7c2c0e519f6ba7f111103e849e4155f94d5f32775c942"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "acab9f043096295e34f7c2c0e519f6ba7f111103e849e4155f94d5f32775c942"
          },
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10311,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strcpy_s(VENDOR_VSTR_POINT(vinf), <size of VENDOR_VSTR_POINT(vinf)>,  hat->vendor_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "software/libcariboulite/src/hat/hat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10311,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strlcpy(VENDOR_VSTR_POINT(vinf),  hat->vendor_name, <size of VENDOR_VSTR_POINT(vinf)>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}